<!--
This HTML/JavaScript file implements a simple voxel world using three.js.  It
builds upon the original world generator by adding basic first‚Äëperson controls
with walking, jumping and very simple collision detection.  The player moves
around the world using the WASD keys and can jump with the space bar.  A
rudimentary height‚Äëmap based collision system prevents the player from falling
through the ground or climbing unnaturally high ledges.  Block types such as
water and leaves are treated as non‚Äësolid, while terrain blocks, logs and
others are solid.  For brevity the code does not implement full swept‚Äëvolume
collision against every voxel in the scene; instead it relies on the
height‚Äëmap and step height checks to approximate block collisions.  Feel free
to tweak the movement constants (speed, jump force, gravity and step height)
to better suit your requirements.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Chunked Voxel World ‚Äì Walk &amp; Jump</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; color: #eee; font-family: Inter, sans-serif; }
        canvas { display: block; touch-action: none; }
        /*
         * Hotbar UI
         *
         * The hotbar is a strip of nine slots that appears at the bottom of the
         * screen when the pointer is locked.  Each slot displays an icon for a
         * block type that can be placed by the player.  The selected slot is
         * highlighted with a glowing border.  A simple slide‚Äëin animation
         * brings the bar into view when entering pointer lock.
         */
        .hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%, 100%);
            display: flex;
            gap: 6px;
            z-index: 500;
            pointer-events: none;
            transition: transform 0.3s ease-out;
        }
        .hotbar.visible {
            transform: translate(-50%, 0);
        }
        .hotbar.interactive {
            pointer-events: auto;
        }
        .hotbar-slot {
            width: 48px;
            height: 48px;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: border-color 0.2s ease-out, box-shadow 0.2s ease-out, background 0.2s ease-out;
        }
        .hotbar-slot img {
            width: 90%;
            height: 90%;
            object-fit: cover;
            pointer-events: none;
            display: none;
        }
        .hotbar-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.7rem;
            color: #fff;
            text-shadow: 0 0 3px #000;
            pointer-events: none;
            user-select: none;
        }
        .hotbar-slot.selected {
            border-color: #ffff00;
            box-shadow: 0 0 6px #ffffaa;
        }
        .hotbar-slot.empty {
            background: rgba(255, 255, 255, 0.05);
            border-style: dashed;
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.5);
        }
        .hotbar-slot.drag-over {
            border-color: #7fffda;
            box-shadow: 0 0 10px rgba(127, 255, 218, 0.7);
        }
        /*
         * Selection tooltip
         *
         * When the player switches hotbar slots, a small faded label appears
         * above the selected slot for a brief moment.  It displays the
         * human‚Äëreadable block name and the number key that selects it.
         */
        .hotbar-tooltip {
            position: absolute;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            white-space: nowrap;
            z-index: 11;
        }
        .hotbar-tooltip.visible {
            opacity: 1;
        }
        /* A simple crosshair when the pointer is locked */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; margin-left: -10px; margin-top: -10px; pointer-events: none; opacity: 0.75; z-index: 5; }
        #crosshair:before, #crosshair:after { content: ''; position: absolute; background: #fff; }
        #crosshair:before { left: 50%; top: 0; width: 2px; height: 20px; margin-left: -1px; }
        #crosshair:after { top: 50%; left: 0; width: 20px; height: 2px; margin-top: -1px; }

        /* Hearts UI */
        .hearts {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            z-index: 12;
            pointer-events: none;
        }
        .hearts .heart {
            font-size: 28px;
            margin-right: 4px;
            color: #e74c3c;
        }
        .hearts .heart.empty {
            color: #444;
        }

        /* Inventory overlay styles */
        .inventory-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.65);
            z-index: 350;
        }
        .inventory-overlay.open {
            display: flex;
        }
        .inventory-panel {
            background: linear-gradient(180deg, rgba(52, 55, 60, 0.98), rgba(36, 38, 42, 0.98));
            border: 2px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            box-shadow: 0 18px 38px rgba(0, 0, 0, 0.45);
            padding: 18px 20px 22px;
            max-width: 720px;
            width: min(92vw, 720px);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .inventory-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .inventory-tabs {
            display: flex;
            gap: 10px;
        }
        .inventory-tab {
            width: 42px;
            height: 42px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: linear-gradient(180deg, rgba(92, 96, 105, 0.92), rgba(60, 63, 70, 0.92));
            color: #e5e9f0;
            font-size: 1.25rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }
        .inventory-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35);
        }
        .inventory-tab.active {
            border-color: rgba(148, 202, 255, 0.8);
            box-shadow: 0 0 0 2px rgba(148, 202, 255, 0.25);
        }
        .inventory-close {
            border: none;
            background: rgba(0, 0, 0, 0.25);
            color: #f0f4ff;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background 0.15s ease;
        }
        .inventory-close:hover {
            background: rgba(0, 0, 0, 0.45);
        }
        .inventory-content {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        .inventory-view {
            display: none;
            flex-direction: column;
            gap: 12px;
        }
        .inventory-view.active {
            display: flex;
        }
        .inventory-search-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(18, 19, 22, 0.45);
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }
        .inventory-search-bar input {
            flex: 1;
            background: rgba(10, 11, 14, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            padding: 6px 10px;
            color: #f3f6ff;
            font-size: 0.95rem;
        }
        .inventory-grid {
            display: grid;
            gap: 8px;
        }
        .inventory-grid.search-grid {
            grid-template-columns: repeat(auto-fill, minmax(58px, 1fr));
            max-height: 46vh;
            overflow-y: auto;
            padding-right: 6px;
        }
        .inventory-grid.backpack-grid {
            grid-template-columns: repeat(9, 58px);
            justify-content: center;
            grid-auto-rows: 58px;
        }
        .inv-slot {
            position: relative;
            width: 58px;
            height: 58px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: linear-gradient(180deg, rgba(74, 78, 88, 0.9), rgba(48, 50, 57, 0.9));
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.35);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: border-color 0.2s ease, transform 0.12s ease;
        }
        .inv-slot img {
            width: 40px;
            height: 40px;
            object-fit: contain;
            pointer-events: none;
        }
        .inv-slot:hover {
            border-color: rgba(160, 206, 255, 0.55);
            transform: translateY(-2px);
        }
        .inv-slot.empty {
            opacity: 0.35;
            cursor: default;
        }
        .inv-slot.empty:hover {
            border-color: rgba(255, 255, 255, 0.1);
            transform: none;
        }
        .inv-slot.drag-over {
            border-color: rgba(130, 224, 255, 0.9);
            box-shadow: 0 0 12px rgba(130, 224, 255, 0.65);
        }
        .inv-count {
            position: absolute;
            bottom: 4px;
            right: 6px;
            font-size: 0.75rem;
            color: #f6fbff;
            text-shadow: 0 0 4px #000;
            font-weight: 600;
        }
        .inventory-empty {
            color: #c3cad6;
            text-align: center;
            padding: 16px 12px 6px;
            font-size: 0.95rem;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 6px;
        }
        .inventory-section-title {
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(228, 235, 252, 0.82);
        }
        .inventory-section-heading {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 8px;
        }
        .recipe-book-button {
            background: linear-gradient(180deg, rgba(82, 92, 112, 0.85), rgba(54, 62, 78, 0.9));
            border: 1px solid rgba(255, 255, 255, 0.16);
            border-radius: 6px;
            color: rgba(240, 244, 255, 0.92);
            cursor: pointer;
            font-size: 1.1rem;
            line-height: 1;
            padding: 6px 10px;
            transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }
        .recipe-book-button:hover {
            border-color: rgba(127, 206, 255, 0.55);
            box-shadow: 0 0 10px rgba(120, 195, 255, 0.35);
        }
        .recipe-book-button.active {
            border-color: rgba(163, 230, 255, 0.75);
            box-shadow: 0 0 14px rgba(140, 215, 255, 0.45);
            transform: translateY(-1px);
        }
        .recipe-book-panel {
            display: none;
            grid-template-columns: 170px 1fr;
            gap: 16px;
            background: linear-gradient(180deg, rgba(40, 45, 56, 0.92), rgba(32, 36, 44, 0.9));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 14px 16px;
            margin-bottom: 16px;
        }
        .recipe-book-panel.open {
            display: grid;
        }
        .recipe-book-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 220px;
            overflow-y: auto;
            padding-right: 6px;
        }
        .recipe-entry {
            display: grid;
            grid-template-columns: 40px 1fr auto;
            align-items: center;
            gap: 10px;
            background: rgba(24, 28, 36, 0.65);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            color: rgba(228, 235, 252, 0.9);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 6px 8px;
            text-align: left;
            transition: border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
        }
        .recipe-entry:hover {
            border-color: rgba(127, 206, 255, 0.5);
            background: rgba(34, 41, 52, 0.8);
        }
        .recipe-entry.active {
            border-color: rgba(163, 230, 255, 0.75);
            background: rgba(40, 54, 70, 0.9);
            box-shadow: 0 0 12px rgba(120, 195, 255, 0.35);
        }
        .recipe-entry-icon {
            width: 36px;
            height: 36px;
            border-radius: 4px;
            background: rgba(15, 18, 24, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .recipe-entry-icon img {
            width: 30px;
            height: 30px;
            pointer-events: none;
        }
        .recipe-entry-name {
            font-weight: 600;
        }
        .recipe-entry-output {
            font-size: 0.8rem;
            color: rgba(172, 206, 255, 0.85);
        }
        .recipe-book-detail {
            background: rgba(20, 24, 32, 0.55);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            padding: 12px 14px;
            font-size: 0.9rem;
            color: rgba(220, 229, 248, 0.88);
            min-height: 180px;
        }
        .recipe-book-detail.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: rgba(170, 186, 210, 0.75);
        }
        .recipe-detail-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        .recipe-detail-icon {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            background: rgba(12, 16, 22, 0.65);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .recipe-detail-icon img {
            width: 34px;
            height: 34px;
            pointer-events: none;
        }
        .recipe-detail-title {
            font-weight: 700;
            color: rgba(235, 242, 255, 0.95);
        }
        .recipe-detail-output {
            font-size: 0.82rem;
            color: rgba(173, 206, 255, 0.85);
        }
        .recipe-detail-summary {
            margin: 6px 0 10px;
            color: rgba(205, 220, 247, 0.85);
        }
        .recipe-pattern-visual {
            display: flex;
            align-items: center;
            gap: 14px;
            margin: 10px 0 12px;
        }
        .recipe-pattern-grid {
            display: grid;
            grid-template-columns: repeat(3, 38px);
            gap: 6px;
        }
        .recipe-cell {
            width: 38px;
            height: 38px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(18, 22, 30, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .recipe-cell.empty {
            border-style: dashed;
            opacity: 0.2;
        }
        .recipe-cell img {
            width: 30px;
            height: 30px;
            pointer-events: none;
        }
        .recipe-arrow {
            font-size: 1.6rem;
            color: rgba(180, 215, 255, 0.85);
            text-shadow: 0 0 12px rgba(120, 195, 255, 0.45);
        }
        .recipe-result {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .recipe-result img {
            width: 40px;
            height: 40px;
            pointer-events: none;
        }
        .recipe-result-count {
            font-size: 0.78rem;
            color: rgba(199, 228, 255, 0.75);
        }
        .recipe-steps {
            margin: 10px 0 0 18px;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .recipe-steps li {
            margin-left: 6px;
        }
        .recipe-detail-note {
            margin-top: 10px;
            font-size: 0.84rem;
            color: rgba(170, 198, 232, 0.8);
        }
        .crafting-area {
            display: flex;
            align-items: center;
            gap: 16px;
            justify-content: center;
        }
        .crafting-grid {
            display: grid;
            grid-template-columns: repeat(3, 58px);
            gap: 8px;
        }
        .craft-slot {
            position: relative;
        }
        .crafting-arrow {
            font-size: 2rem;
            color: rgba(214, 229, 255, 0.8);
            text-shadow: 0 0 12px rgba(120, 180, 255, 0.45);
        }
        .result-slot {
            background: linear-gradient(180deg, rgba(82, 116, 86, 0.95), rgba(58, 82, 61, 0.95));
            border-color: rgba(163, 230, 178, 0.55);
        }
        .result-slot.empty {
            background: linear-gradient(180deg, rgba(60, 63, 70, 0.8), rgba(48, 50, 57, 0.8));
            border-color: rgba(255, 255, 255, 0.1);
        }

        /*
         * Main menu overlay
         *
         * The main menu appears when the page first loads.  It covers the
         * entire viewport with a background image and a translucent panel on
         * the right containing the game logo and menu buttons.  The Play
         * button starts the game, while the remaining buttons are disabled
         * and greyed out.  Disabled buttons show a not‚Äëallowed cursor.
         */
        .main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://i.postimg.cc/R0pTSf4G/image.png');
            background-size: cover;
            background-position: center;
            display: flex;
            justify-content: flex-end;
            z-index: 100;
            /* Slowly pan and zoom the menu background to give it life */
            animation: menuBgAnim 30s ease-in-out infinite alternate;
        }
        .menu-panel {
            width: 28%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            padding: 60px 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
        }
        .menu-logo {
            width: 140px;
            height: auto;
            margin-bottom: 40px;
        }
        .menu-buttons {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }
        .menu-btn {
            width: 80%;
            padding: 14px 10px;
            font-size: 1rem;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .menu-btn:hover:not(.disabled) {
            background: rgba(100, 100, 100, 0.8);
        }
        .menu-btn.play-btn {
            background: #4a93ff;
            border-color: #4a93ff;
        }
        .menu-btn.play-btn:hover {
            background: #3a83ee;
        }
        .menu-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Version text displayed on the bottom left of the main menu */
        .version-text {
            position: absolute;
            bottom: 8px;
            left: 12px;
            color: rgba(255,255,255,0.7);
            font-size: 0.8rem;
            z-index: 101;
            pointer-events: none;
        }

        /* Animation for the main menu background: slowly pan horizontally and zoom */
        @keyframes menuBgAnim {
            0%   { background-size: 110% 110%; background-position: 48% 50%; }
            50%  { background-size: 115% 115%; background-position: 52% 50%; }
            100% { background-size: 110% 110%; background-position: 48% 50%; }
        }

        /* Footer row for bottom of the menu panel.  Contains share/discord
           icons on the left and Realms/Quit buttons on the right. */
        .menu-footer {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }
        .menu-footer-left, .menu-footer-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Square icon buttons for share and Discord. */
        .icon-btn {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #555;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
        }
        .icon-btn:hover {
            background: rgba(100,100,100,0.8);
        }
        .icon-btn img, .icon-btn svg {
            width: 70%;
            height: 70%;
            object-fit: contain;
            pointer-events: none;
        }

        /* Style for the loading screen overlay */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #000;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
        }
        .loading-screen.visible {
            opacity: 1;
            pointer-events: all;
        }
        .loading-logo {
            width: 180px;
            height: auto;
            margin-bottom: 20px;
        }
        .loading-bar {
            width: 60%;
            height: 8px;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .loading-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -50%;
            width: 50%;
            height: 100%;
            background: #4a93ff;
            animation: loadingAnim 2s infinite;
        }
        .loading-text {
            color: #fff;
            font-size: 1.2rem;
            margin-top: 12px;
        }
        @keyframes loadingAnim {
            from { left: -50%; }
            to   { left: 100%; }
        }

        /* Pause and options menu overlays.  These menus reuse the main menu
           layout but do not include a background image.  They cover the
           viewport with a translucent backdrop and slide in a panel from
           the right. */
        .pause-menu, .options-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: flex-end;
            align-items: stretch;
            background: rgba(0, 0, 0, 0.4);
            z-index: 150;
        }
        .pause-menu .menu-panel,
        .options-menu .menu-panel {
            width: 28%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            padding: 60px 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
        }
        .options-menu .menu-panel {
            justify-content: flex-start;
        }
        .options-menu .options-content {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-top: 20px;
        }
        .options-menu .option-row {
            width: 80%;
            color: #fff;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
        }
        .options-menu .option-row input[type=range] {
            width: 100%;
            margin-top: 6px;
        }
    </style>
    <!-- three.js core and examples modules -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <!-- Crosshair remains visible in the centre of the screen when the pointer is locked. -->
    <div id="crosshair"></div>
    <!-- Hotbar: nine selectable slots for block placement.  The contents are
         populated by the script in initHotbar(). -->
    <div id="hotbar" class="hotbar"></div>
    <!-- Tooltip displayed briefly above the selected hotbar slot when switching blocks -->
    <div id="selectionTooltip" class="hotbar-tooltip"></div>

    <!-- Hearts display for player health.  Five heart icons show the
         player's remaining health.  Full hearts are red and empty hearts
         are grey. -->
    <div id="heartContainer" class="hearts"></div>

    <!-- Death screen overlay.  When the player dies this overlay
         appears on top of the game showing a message and buttons to
         respawn or quit. -->
    <div id="deathScreen" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:300; align-items:center; justify-content:center; flex-direction:column; color:#fff; font-size:2rem; text-align:center;">
        <div>You Died</div>
        <div style="margin-top:20px; display:flex; gap:20px;">
            <button id="respawnButton" class="menu-btn play-btn" style="font-size:1.2rem;">Respawn</button>
            <button id="quitButton" class="menu-btn" style="font-size:1.2rem;">Quit</button>
        </div>
    </div>

    <!-- Inventory overlay.  Press E to toggle this overlay.  It shows a
         searchable list of block types and your current inventory counts.
         Clicking on an item will switch the hotbar selection to that
         block type.  Close the inventory with the close button or by
         pressing E again. -->
    <div id="inventoryOverlay" class="inventory-overlay">
        <div class="inventory-panel">
            <div class="inventory-header">
                <div class="inventory-tabs">
                    <button id="inventorySearchTab" class="inventory-tab active" title="Search inventory">
                        üîç
                    </button>
                    <button id="inventoryBackpackTab" class="inventory-tab" title="Backpack">
                        üéí
                    </button>
                </div>
                <button id="closeInventory" class="inventory-close" aria-label="Close inventory">√ó</button>
            </div>
            <div class="inventory-content">
                <div id="inventorySearchView" class="inventory-view active">
                    <div class="inventory-search-bar">
                        <input id="inventorySearch" type="text" placeholder="Search items‚Ä¶" autocomplete="off" />
                    </div>
                    <div id="inventoryEmptyState" class="inventory-empty" style="display:none;">Collect blocks to fill your inventory.</div>
                    <div id="inventoryGrid" class="inventory-grid search-grid"></div>
                </div>
                <div id="inventoryBackpackView" class="inventory-view">
                    <div class="inventory-section-heading">
                        <div class="inventory-section-title">Crafting</div>
                        <button id="recipeBookToggle" class="recipe-book-button" type="button" title="Open recipe book" aria-controls="recipeBookPanel" aria-expanded="false">
                            üìñ
                        </button>
                    </div>
                    <div id="recipeBookPanel" class="recipe-book-panel" hidden>
                        <div id="recipeBookList" class="recipe-book-list"></div>
                        <div id="recipeBookDetail" class="recipe-book-detail empty">Select a recipe to view crafting steps.</div>
                    </div>
                    <div class="crafting-area">
                        <div id="craftingGrid" class="crafting-grid"></div>
                        <div class="crafting-arrow">‚ûú</div>
                        <div id="craftingResultSlot" class="inv-slot result-slot empty" title="Crafting result">
                            <img alt="" />
                            <span class="inv-count"></span>
                        </div>
                    </div>
                    <div class="inventory-section-title">Backpack</div>
                    <div id="backpackGrid" class="inventory-grid backpack-grid"></div>
                </div>
            </div>
        </div>
    </div>
    <!-- Main menu overlay.  This full‚Äëscreen overlay is displayed on page load
         and hides the game world until the player clicks the Play button.
         The background image is set via CSS below.  The right‚Äëhand panel
         contains the logo and menu buttons. -->
    <div id="mainMenu" class="main-menu">
        <div class="menu-panel">
            <img id="menuLogo" class="menu-logo" src="https://i.postimg.cc/brdvY1ty/logo.png" alt="Logo" />
            <div class="menu-buttons">
                <button id="playButton" class="menu-btn play-btn">Play</button>
                <!-- Enable Options button on the main menu.  Assign an ID so it can
                     open the options menu overlay.  The disabled attribute is
                     removed so that the button is clickable. -->
                <button id="mainOptionsButton" class="menu-btn">Options‚Ä¶</button>
                <button class="menu-btn disabled" disabled>Mods</button>
            </div>
            <div class="menu-footer">
                <div class="menu-footer-left">
                    <button id="shareButton" class="icon-btn" title="Share">
                        <img src="https://i.postimg.cc/6624FM3k/image-removebg-preview-4.png" alt="Share" />
                    </button>
                    <button id="discordButton" class="icon-btn" title="Discord">
                        <img src="https://i.postimg.cc/SxpSTr2B/image.png" alt="Discord" />
                    </button>
                </div>
                <div class="menu-footer-right">
                    <button class="menu-btn disabled" disabled>Realms</button>
                    <button class="menu-btn disabled" disabled>Quit</button>
                </div>
            </div>
        </div>
        <div id="versionText" class="version-text">VoxelVerse v0.1</div>
    </div>

    <!-- Pause menu overlay.  Appears when the game is paused via the Escape key. -->
    <div id="pauseMenu" class="pause-menu">
        <div class="menu-panel">
            <img class="menu-logo" src="https://i.postimg.cc/brdvY1ty/logo.png" alt="Logo" />
            <div class="menu-buttons">
                <button id="resumeButton" class="menu-btn play-btn">Resume</button>
                <button id="pauseOptionsButton" class="menu-btn">Options‚Ä¶</button>
            </div>
            <div class="menu-footer">
                <div class="menu-footer-left">
                    <button id="pauseShareButton" class="icon-btn" title="Share">
                        <img src="https://i.postimg.cc/6624FM3k/image-removebg-preview-4.png" alt="Share" />
                    </button>
                    <button id="pauseDiscordButton" class="icon-btn" title="Discord">
                        <img src="https://i.postimg.cc/SxpSTr2B/image.png" alt="Discord" />
                    </button>
                </div>
                <div class="menu-footer-right">
                    <button id="pauseQuitButton" class="menu-btn">Quit</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Options menu overlay.  Provides sliders for adjusting audio levels. -->
    <div id="optionsMenu" class="options-menu">
        <div class="menu-panel">
            <img class="menu-logo" src="https://i.postimg.cc/brdvY1ty/logo.png" alt="Logo" />
            <div class="options-content">
                <div class="option-row">
                    <label for="masterVolumeSlider">Master Volume</label>
                    <input id="masterVolumeSlider" type="range" min="0" max="100" />
                </div>
                <div class="option-row">
                    <label for="musicVolumeSlider">Music Volume</label>
                    <input id="musicVolumeSlider" type="range" min="0" max="100" />
                </div>
                <div class="option-row">
                    <label for="sfxVolumeSlider">Sound Effects Volume</label>
                    <input id="sfxVolumeSlider" type="range" min="0" max="100" />
                </div>
            </div>
            <div class="menu-footer">
                <div class="menu-footer-left"></div>
                <div class="menu-footer-right">
                    <button id="optionsBackButton" class="menu-btn">Back</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading screen displayed during world generation -->
    <div id="loadingScreen" class="loading-screen">
        <img class="loading-logo" src="https://i.postimg.cc/brdvY1ty/logo.png" alt="VoxelVerse Logo" />
        <div class="loading-bar"></div>
        <div class="loading-text">Generating world‚Ä¶</div>
    </div>

<script>
(() => {
    // --- Config ---
    const CHUNK_SIZE = 16;
    // Increase the vertical build limit so players can construct taller
    // structures.  Raising the chunk height also lifts the maximum
    // generation height for terrain.  Previously this was 48.  It is
    // now raised to 80 to allow higher builds and more vertical space.
    // Increase the vertical build limit further.  Minecraft worlds allow
    // players to build very high structures.  Raising this to 128 gives
    // plenty of headroom while still being practical for rendering.  It
    // effectively removes the low maximum height the user complained about.
    const CHUNK_HEIGHT = 128;
    // Define a global water level relative to the world height.  Water will
    // fill up to this level in low areas.  Using a fraction of the world
    // height ensures that water bodies appear at sensible elevations even
    // when the chunk height changes.  You can adjust the multiplier to
    // raise or lower the sea level globally.  For example 0.25 means the
    // lowest quarter of the world is underwater.
    const WATER_LEVEL = Math.floor(CHUNK_HEIGHT * 0.25);
    const VIEW_DISTANCE_CHUNKS = 3;
    const WORLD_FREQUENCY = 0.02;
    const OCTAVES = 4;
    const PERSISTENCE = 0.5;
    // Day/night cycle configuration.  The time of day advances from 0 to 1
    // over the course of DAY_DURATION seconds.  At 0.25 the sun rises, at
    // 0.5 it reaches its highest point, at 0.75 it sets and at 1.0 it
    // returns to midnight.  The sun and moon are positioned on a large
    // circle around the origin at distance SUN_DISTANCE.  Star points are
    // scattered on a sphere around the player and fade in at night.
    const DAY_DURATION = 240; // seconds for a complete day/night cycle
    // Distance from the world origin to the centre of the sun/moon orbit.  A
    // smaller value brings the sun and moon closer to the camera so they
    // appear larger and more prominent on the horizon.  Minecraft's
    // celestial bodies are relatively close to the player, so a value of
    // 300 works well for our needs.
    const SUN_DISTANCE  = 300; // radius of sun/moon orbit
    const STAR_COUNT    = 400;   // number of stars in the night sky
    // Height above the ground at which the sun and moon orbit.  This is
    // calculated relative to the chunk height so the celestial bodies
    // appear near the horizon at the edge of the world.  A small offset
    // above CHUNK_HEIGHT ensures they remain visible above terrain.
    const SUN_HEIGHT    = CHUNK_HEIGHT + 10;
    // Cave noise configuration.  Underground spaces are carved by sampling
    // layered 3D Perlin noise fields instead of a simple probability.  The
    // base and detail frequencies control tunnel width and branching,
    // while the cavern frequency spawns larger chambers.  Threshold
    // determines how much of the stone is removed and CAVE_MIN_Y limits
    // generation to deeper levels so the surface remains intact.
    const CAVE_BASE_FREQUENCY = 0.038;
    const CAVE_DETAIL_FREQUENCY = 0.085;
    const CAVERN_FREQUENCY = 0.02;
    const CAVE_THRESHOLD = 0.6;
    const CAVE_MIN_Y = 6;
    const CAVE_VERTICAL_RIPPLE_FREQ = 0.22;
    const CAVE_VERTICAL_RIPPLE_STRENGTH = 0.08;
    const CAVE_CAVERN_THRESHOLD = 0.7;
    const CAVE_CAVERN_BOOST = 0.35;

    const PLAINS_MASK_FREQUENCY = 0.045;
    const PLAINS_THRESHOLD = 0.58;
    const PLAINS_BASE = 0.28;
    const PLAINS_VARIATION = 0.24;

    const OCEAN_MASK_FREQUENCY = 0.12;
    const OCEAN_THRESHOLD = 0.46;
    const OCEAN_SHELF_BLEND = 0.12;
    const OCEAN_MAX_DEPTH = 14;
    const OCEAN_FLOOR_JITTER = 3.5;

    // Cave entrance configuration.  A small chance per column on the surface
    // produces an entrance that opens downward into the world.  Each
    // entrance carves a circular hole with a given radius and depth, giving
    // the player access to underground caves from the surface.
    const ENTRANCE_CHANCE = 0.004;
    const ENTRANCE_RADIUS = 2;
    const ENTRANCE_DEPTH = 6;
    // Terrain layering configuration.  We always place 3 layers of dirt
    // directly beneath the top surface, and we want the top 10 layers of
    // stone below those to be visible and selectable.  Deeper stone
    // blocks remain hidden until exposed.  Adjust these constants to
    // change how many layers of each material are visible.
    const DIRT_LAYERS = 3;
    const STONE_VISIBLE_LAYERS = 10;
    // Player movement constants
    // Height of the player in world units.  Each block in the world is one unit tall,
    // so a two‚Äëblock tall player has a height of 2.
    const PLAYER_HEIGHT = 2;
    const MOVE_SPEED = 8;          // units per second
    const JUMP_VELOCITY = 7;       // upward velocity when jumping
    const GRAVITY = 20;            // downward acceleration (units/s^2)
    const STEP_MAX = 1.0;          // maximum step height between neighbouring columns
    const SWIM_SPEED = 4.5;        // horizontal swim speed while submerged
    const SWIM_ASCEND_SPEED = 3.2; // upward swim velocity when rising
    const SWIM_SINK_SPEED = 1.2;   // downward swim velocity when idle
    const WATER_DRAG = 4.2;        // damping applied to swim velocity transitions
    const UNDERWATER_BOB_SPEED = 1.8;   // bob frequency when floating at the surface
    const UNDERWATER_BOB_AMPLITUDE = 0.08; // camera bob amplitude while treading water
    const UNDERWATER_MUSIC_ATTENUATION = 0.55;
    const UNDERWATER_SFX_ATTENUATION = 0.65;
    const UNDERWATER_HTML_ATTENUATION = 0.6;
    const UNDERWATER_SFX_PITCH = 0.92;
    const UNDERWATER_MUSIC_PITCH = 0.95;

    // Step sound configuration.  These URLs point to the Minecraft grass step
    // sound effects hosted on the public mcasset.cloud CDN.  The game will
    // randomly pick one of these sounds when the player walks, jumps or lands.
    const STEP_SOUND_INTERVAL = 0.35; // minimum time (in seconds) between step sounds while walking
    const STEP_SOUND_URLS = [
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/step/grass1.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/step/grass2.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/step/grass3.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/step/grass4.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/step/grass5.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/step/grass6.ogg'
    ];

    // Dig/break sound configuration.  Different categories correspond to
    // different block types.  When a block is broken a random sound from
    // the appropriate category will be played.  These sounds are also
    // hosted on mcasset.cloud.
    const DIG_SOUND_URLS = {
        grass: [
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/grass1.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/grass2.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/grass3.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/grass4.ogg'
        ],
        stone: [
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/stone1.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/stone2.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/stone3.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/stone4.ogg'
        ],
        wood: [
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/wood1.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/wood2.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/wood3.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/dig/wood4.ogg'
        ]
    };

    // --- Shared block geometry & materials ---
    const cubeGeometry = new THREE.BoxBufferGeometry(1,1,1);
    const loadingManager = new THREE.LoadingManager();
    const iconReadyCallbacks = [];
    let iconsReady = false;
    let hotbarIcons = {};
    function onIconsReady(cb) {
        if (iconsReady) {
            cb();
        } else {
            iconReadyCallbacks.push(cb);
        }
    }
    // Prepare textures for certain block types.  We load these textures once
    // up‚Äëfront so that they can be reused across all chunks.  Setting
    // crossOrigin ensures that images hosted on external domains (like
    // postimg.cc) load correctly in the browser.
    const textureLoader = new THREE.TextureLoader(loadingManager);
    if (textureLoader.setCrossOrigin) textureLoader.setCrossOrigin('anonymous');
    // Grass texture ‚Äì this replaces the solid green colour with the provided
    // pixel art grass.  Using NearestFilter preserves the crisp pixels and
    // prevents blurring when the texture is magnified.  The texture will
    // automatically repeat on each cube face.
    const grassTexture = textureLoader.load('https://i.postimg.cc/KzggQfJC/image.png');
    // Use linear filtering and mipmaps to avoid excessive pixelation.  These
    // settings smooth the texture when viewed at an angle or from a distance.
    grassTexture.magFilter = THREE.LinearFilter;
    grassTexture.minFilter = THREE.LinearMipmapLinearFilter;
    // Enable a bit of anisotropy for better texture quality; a modest value
    // improves clarity without being too expensive.
    grassTexture.anisotropy = 4;
    // Log (wood) texture ‚Äì used for tree trunks.  The same filtering is
    // applied to keep the pixels sharp.  Logs are opaque so no alphaTest is
    // required on the material.
    const woodTexture = textureLoader.load('https://i.postimg.cc/YqxLXhz2/image.png');
    woodTexture.magFilter = THREE.LinearFilter;
    woodTexture.minFilter = THREE.LinearMipmapLinearFilter;
    woodTexture.anisotropy = 4;
    // Leaves texture ‚Äì contains transparency (alpha channel) so we enable
    // transparency on the material and set an alphaTest to discard fully
    // transparent pixels.  NearestFilter again maintains crisp edges.
    const leavesTexture = textureLoader.load('https://i.postimg.cc/BnV6yDL3/image.png');
    leavesTexture.magFilter = THREE.LinearFilter;
    leavesTexture.minFilter = THREE.LinearMipmapLinearFilter;
    leavesTexture.anisotropy = 4;
    // Define block materials.  For terrain that doesn't require textures
    // (dirt, stone, sand and water) we keep the existing solid colours.  For
    // grass, wood and leaves we supply the loaded textures.  Leaves are
    // semi‚Äëtransparent and rely on alphaTest to correctly discard fully
    // transparent pixels, allowing you to see through the gaps in the foliage.
    // Additional textures for dirt, stone and bedrock.  These textures
    // replace the simple coloured materials used previously.  Like the
    // existing textures, they use linear filtering and mipmaps to avoid
    // aliasing at distance, with modest anisotropy for improved clarity.
    const dirtTexture  = textureLoader.load('https://i.postimg.cc/pTMN7XPk/image.png');
    dirtTexture.magFilter  = THREE.LinearFilter;
    dirtTexture.minFilter  = THREE.LinearMipmapLinearFilter;
    dirtTexture.anisotropy = 4;
    const stoneTexture = textureLoader.load('https://i.postimg.cc/qqQ9zsyZ/image.png');
    stoneTexture.magFilter  = THREE.LinearFilter;
    stoneTexture.minFilter  = THREE.LinearMipmapLinearFilter;
    stoneTexture.anisotropy = 4;
    const bedrockTexture = textureLoader.load('https://i.postimg.cc/Wbh9Gcv4/image.png');
    bedrockTexture.magFilter  = THREE.LinearFilter;
    bedrockTexture.minFilter  = THREE.LinearMipmapLinearFilter;
    bedrockTexture.anisotropy = 4;
    const blockMaterials = {
        grass: new THREE.MeshStandardMaterial({ map: grassTexture }),
        dirt:  new THREE.MeshStandardMaterial({ map: dirtTexture }),
        stone: new THREE.MeshStandardMaterial({ map: stoneTexture }),
        sand:  new THREE.MeshStandardMaterial({ color: 0xe6d4a0 }),
        water: new THREE.MeshStandardMaterial({ color: 0x4a7ad1, transparent: true, opacity: 0.6 }),
        wood:  new THREE.MeshStandardMaterial({ map: woodTexture }),
        leaves:new THREE.MeshStandardMaterial({ map: leavesTexture, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide }),
        bedrock: new THREE.MeshStandardMaterial({ map: bedrockTexture }),
        snow:   new THREE.MeshStandardMaterial({ color: 0xf5fbff, roughness: 0.45, metalness: 0.05 }),
        ice:    new THREE.MeshStandardMaterial({ color: 0x9bd8ff, transparent: true, opacity: 0.7, roughness: 0.12, metalness: 0.15, envMapIntensity: 0.6 }),
        moss:   new THREE.MeshStandardMaterial({ color: 0x3b8a64, roughness: 0.85, metalness: 0.05 }),
        glowstone: new THREE.MeshStandardMaterial({ color: 0xfff2b3, emissive: 0xffd76b, emissiveIntensity: 1.5, roughness: 0.3 }),
        cactus: new THREE.MeshStandardMaterial({ color: 0x2f9b57, roughness: 0.9, metalness: 0.05 }),
        // Ores and lava.  Ores are represented by coloured materials
        // rather than textures for simplicity.  Lava is an emissive
        // semi‚Äëtransparent material that glows.  These materials can be
        // referenced by name in the voxel generation logic below.
        iron:    new THREE.MeshStandardMaterial({ color: 0xd8d8d8 }),
        copper:  new THREE.MeshStandardMaterial({ color: 0xb46c00 }),
        ruby:    new THREE.MeshStandardMaterial({ color: 0xff3c44 }),
        diamond: new THREE.MeshStandardMaterial({ color: 0x33ffe6 }),
        coal:    new THREE.MeshStandardMaterial({ color: 0x222222 }),
        lava:    new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff4500, emissiveIntensity: 1.0, transparent: true, opacity: 0.85 })
    };
    const emptyHandMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0 });
    emptyHandMaterial.depthTest = false;
    emptyHandMaterial.depthWrite = false;

    // --- Block breaking crack textures ---
    // Minecraft uses a set of destroy stage textures (0‚Äì9) to show cracks on a
    // block as it is being broken.  We load these textures from mcasset.cloud
    // once at startup.  Each texture is a 16√ó16 image containing only
    // transparent cracks; they will be used as an overlay on the block being
    // broken.  Nearest filtering preserves crisp pixels.
    const destroyTextures = [];
    const destroyMaterials = [];
    for (let i = 0; i < 10; i++) {
        const dt = textureLoader.load(`https://assets.mcasset.cloud/1.21.5/assets/minecraft/textures/block/destroy_stage_${i}.png`);
        dt.magFilter = THREE.NearestFilter;
        dt.minFilter = THREE.NearestFilter;
        dt.anisotropy = 4;
        destroyTextures.push(dt);
        // Use a Lambert material for cracks so that lighting and shading
        // contribute to the appearance of depth.  Set side to
        // DoubleSide so the cracks texture renders on both sides of the
        // faces.  Transparency ensures only the crack lines are visible.
        destroyMaterials.push(new THREE.MeshLambertMaterial({ map: dt, transparent: true, side: THREE.DoubleSide }));
    }
    // Cracks overlay mesh.  This mesh will be placed over the targeted block
    // during breaking and will display the appropriate crack stage.  It is
    // created during init() and updated each frame when breaking.  To give
    // the cracks a more three‚Äëdimensional appearance we will generate a
    // custom box geometry and slightly extrude its faces along their normals.
    let cracksMesh;

    // --- Three.js / world state ---
    let scene, camera, renderer;
    const chunkMap = new Map();
    let seed = Math.floor(Math.random() * 1e9);
    let perlinNoise;
    let heatNoise;
    let moistureNoise;
    let mysticNoise;
    let skyIslandNoise;
    let caveNoisePrimary;
    let caveNoiseDetail;
    let cavernNoise;
    const biomeCache = new Map();
    // A global height map storing the highest solid block for each (x,z)
    const heightMap = {};
    // A map storing information about each voxel in the world.  The key is
    // `${x},${y},${z}` and the value is an object `{ type: string, chunk: string }`.
    // This allows us to determine the type of any block for collision, picking
    // and modification.  When chunks are disposed the corresponding entries
    // are removed.  Dynamically placed blocks use a special chunk key of
    // 'mod'.
    const voxelMap = new Map();
    // A map linking world coordinates to their instanced mesh entry.  Each
    // value is an object `{ mesh: InstancedMesh|Mesh, index: number, chunk: string, type: string }`.
    // For base terrain this references instanced meshes, for dynamically
    // placed blocks the mesh property refers to a standalone Mesh and the
    // index is ignored.
    const voxelInstances = new Map();
    // A list of dynamically created block meshes (placed blocks) so we can
    // remove them easily when breaking.  Each entry is a THREE.Mesh.
    const modifiedMeshes = [];
    const leafDecayQueue = [];
    const leafDecayScheduled = new Map();
    const LEAF_DECAY_RADIUS = 4;
    // Selection state for placing blocks.  selectableTypes defines which
    // materials the player can place.  selectedIndex indexes into this
    // array.  Press number keys 1‚Äì4 to change selection.
    // Selected block index and the list of selectable block types.  The
    // hotbar presents nine slots that can be populated by the player using the
    // inventory.  Initially all slots are empty and can be assigned freely.
    let selectedIndex = 0;
    const selectableTypes = new Array(9).fill(null);
    // Hotbar DOM elements will be stored here after initialisation.  Each
    // entry corresponds to a slot in the bar so that selection highlights
    // can be easily toggled.
    let hotbarSlots = [];
    // Breaking state.  When the player holds the left mouse button on a
    // block this timer counts up; after BREAK_DURATION milliseconds the
    // targeted block is removed.  If the target changes or the mouse is
    // released the timer resets.
    // Duration (in milliseconds) to break a block.  Reduced from 5s to 3s
    // per user request.  The cracks overlay and break logic use this
    // constant to determine progress.
    const BREAK_DURATION = 3000;
    const BREAK_SOUND_MIN = 0.22;
    const BREAK_SOUND_MAX = 0.45;
    const PLACE_REPEAT_INTERVAL = 0.22;
    let currentBreakDuration = BREAK_DURATION;
    let isBreaking = false;
    let breakTarget = null;
    let breakStartTime = 0;
    let breakSoundElapsed = 0;
    let breakSoundDelay = BREAK_SOUND_MAX;
    let leftMouseDown = false;
    let rightMouseDown = false;
    let placeHoldCooldown = 0;
    // Highlight mesh shown around the currently targeted block.  This will
    // be created during init().
    let highlightMesh;
    // Hand and block meshes for the first‚Äëperson view.  handBlock shows
    // the currently selected block type; handGroup groups the arm and block
    // so that they can be animated together.
    let handBlock;
    const handMaterialCache = new Map();
    let handGroup;
    const handItemMeshes = {};
    let activeHandTool = null;
    const TOOL_VARIANTS = ['wooden', 'stone', 'copper', 'iron', 'diamond'];
    const TOOL_VARIANT_LABELS = {
        wooden: 'Wooden',
        stone: 'Stone',
        copper: 'Copper',
        iron: 'Iron',
        diamond: 'Diamond'
    };
    const TOOL_KINDS = ['axe', 'pickaxe', 'sword', 'shovel'];
    const TOOL_KIND_LABELS = {
        axe: 'Axe',
        pickaxe: 'Pickaxe',
        sword: 'Sword',
        shovel: 'Shovel'
    };
    const TOOL_VARIANT_STYLE = {
        wooden: {
            headPrimary: 0xb37a45,
            headSecondary: 0xd9a062,
            edge: 0xf3d9ad,
            emissive: 0x25160a,
            wrap: 0x4c2f16
        },
        stone: {
            headPrimary: 0x6f6f6f,
            headSecondary: 0x9d9d9d,
            edge: 0xe7e7e7,
            emissive: 0x1e1e1e,
            wrap: 0x3b3229
        },
        copper: {
            headPrimary: 0xa55f24,
            headSecondary: 0xd68138,
            edge: 0xffddbb,
            emissive: 0x331400,
            wrap: 0x513019
        },
        iron: {
            headPrimary: 0xa9b6c6,
            headSecondary: 0xd9e4f5,
            edge: 0xffffff,
            emissive: 0x2e3e52,
            wrap: 0x2f3b4d
        },
        diamond: {
            headPrimary: 0x0fa7bd,
            headSecondary: 0x7cf4ff,
            edge: 0xcffbff,
            emissive: 0x0a4452,
            wrap: 0x1e4d56
        }
    };
    const TOOL_STATS = {};
    // Base hand position and rotation.  These will be captured after the
    // hand group is positioned in init().  When animations end the
    // hand will return to these defaults.
    let handBasePosition;
    let handBaseRotation;
    let handBobTime = 0;
    let handBobStrength = 0;
    const handBobPosition = new THREE.Vector3();
    const handBobRotation = new THREE.Euler();
    const handFinalPosition = new THREE.Vector3();
    const handFinalRotation = new THREE.Euler();
    // Hand animation state: when placing or breaking we animate the hand for
    // a short duration.  handAnimTime tracks the progress (0..1) and
    // handAnimType is 'place' or 'break'.
    let handAnimTime = 0;
    let handAnimType = null;

    // Dig sound objects categorised by block type.  Populated during init().
    const digSounds = {};

    // --- Sky, sun, moon, stars and clouds ---
    // The day/night cycle state.  dayTime advances from 0 to 1 over
    // DAY_DURATION seconds.  A value of 0.25 corresponds to sunrise and
    // 0.75 corresponds to sunset.
    let dayTime = Math.random();
    // Sprites and groups for the sky elements.  These will be
    // initialised in initSky() and updated each frame in the animation
    // loop.  cloudGroup holds billboards for clouds; sunMesh and
    // moonMesh are small quads representing the sun and moon; stars is a
    // Points object containing many faint points for the night sky.
    let cloudGroup;
    let sunMesh;
    let moonMesh;
    let stars;
    // Light references for dynamic adjustment during the day/night cycle.
    let ambientLight;
    let sunLight;
    // A texture for cloud sprites, generated procedurally at runtime.
    let cloudTexture;

    // Debris pieces spawned when a block breaks.  Each entry is an object
    // containing a mesh, a velocity vector, and remaining life in seconds.
    const debrisPieces = [];

    // Dropped items that spawn when blocks are broken.  Each entry has a
    // mesh (a small cube), the block type, and a velocity.  Items fall
    // until they reach the ground, then can be picked up by the player.
    const droppedItems = [];
    const DROP_HALF_SIZE = 0.2;

    // Ambient fauna such as fireflies.  Each entry stores a mesh and motion
    // parameters for lightweight animation in the main loop.
    const ambientCreatures = [];

    // Cached biome under the player and the current sky brightness.  These
    // values are updated each frame and consumed by the sky/lighting logic.
    let currentBiomeInfo = null;
    let skyBrightness = 1;

    // Queue of fluid cells to process for water flowing.  When water is
    // placed or spawns, a record is added to this queue.  Each frame we
    // process a few cells to spread water to adjacent empty blocks.
    const fluidQueue = [];

    let swimBobTime = 0;
    let swimBobOffset = 0;
    let underwaterAudioActive = false;
    let musicUnderwaterFilter = null;
    const underwaterSfxFilters = new WeakMap();

    // Simple inventory data structure.  Keys are block types and values
    // are counts.  When items are picked up they are added here.  When
    // placing blocks the count is decremented.  The inventory UI will
    // display these counts.  New types are added dynamically as needed.
    const inventory = {};
    const discoveredTypes = new Set();
    const craftingGridState = new Array(9).fill(null);
    const craftingSlots = [];
    let craftingResultSlot = null;
    let currentCraftingResult = null;
    let activeInventoryView = 'search';

    // Whether the inventory overlay is currently open.  Toggled with
    // the 'E' key.  When open, pointer lock is released and game
    // controls are paused.
    let inventoryOpen = false;

    // --- Audio volume settings ---
    // Master, music and sound effect volumes range from 0 to 1.  These
    // determine the overall loudness of all sounds in the game.  Values
    // are persisted to localStorage and loaded on startup.
    let masterVolume = 1.0;
    let musicVolume  = 0.2;
    let sfxVolume    = 0.5;
    function loadVolumeSettings() {
        const m  = parseFloat(localStorage.getItem('voxelverse_masterVolume'));
        const mu = parseFloat(localStorage.getItem('voxelverse_musicVolume'));
        const sf = parseFloat(localStorage.getItem('voxelverse_sfxVolume'));
        if (!isNaN(m))  masterVolume = Math.min(Math.max(m, 0), 1);
        if (!isNaN(mu)) musicVolume  = Math.min(Math.max(mu, 0), 1);
        if (!isNaN(sf)) sfxVolume    = Math.min(Math.max(sf, 0), 1);
    }
    function saveVolumeSettings() {
        localStorage.setItem('voxelverse_masterVolume', masterVolume.toString());
        localStorage.setItem('voxelverse_musicVolume', musicVolume.toString());
        localStorage.setItem('voxelverse_sfxVolume', sfxVolume.toString());
    }
    // Apply current volume settings to all audio objects.  Base volumes
    // for various sound categories are multiplied by master and
    // category volumes.
    function applyVolumeSettings() {
        // Read current volumes from the global window if available.  This
        // allows the pause/options menu to update volumes outside this
        // closure.  Fallback to local variables if the globals are not
        // defined.
        const mVol  = (typeof window.masterVolume === 'number') ? window.masterVolume : masterVolume;
        const muVol = (typeof window.musicVolume  === 'number') ? window.musicVolume  : musicVolume;
        const sfVol = (typeof window.sfxVolume    === 'number') ? window.sfxVolume    : sfxVolume;
        // Menu music uses HTMLAudioElement volume property
        if (typeof menuMusicAudio !== 'undefined' && menuMusicAudio) {
            menuMusicAudio.volume = mVol * muVol;
        }
        // In‚Äëgame background music uses Three.js Audio objects
        if (typeof music !== 'undefined' && music) {
            const musicScale = underwaterAudioActive ? UNDERWATER_MUSIC_ATTENUATION : 1;
            music.setVolume(mVol * muVol * musicScale);
        }
        // Step sounds
        if (Array.isArray(stepSounds)) {
            stepSounds.forEach((s) => {
                if (s && typeof s.setVolume === 'function') {
                    const sfxScale = underwaterAudioActive ? UNDERWATER_SFX_ATTENUATION : 1;
                    s.setVolume(0.5 * mVol * sfVol * sfxScale);
                }
            });
        }
        // Dig/break sounds
        if (digSounds) {
            Object.keys(digSounds).forEach((cat) => {
                digSounds[cat].forEach((s) => {
                    if (s && typeof s.setVolume === 'function') {
                        const sfxScale = underwaterAudioActive ? UNDERWATER_SFX_ATTENUATION : 1;
                        s.setVolume(0.5 * mVol * sfVol * sfxScale);
                    }
                });
            });
        }
        // UI sounds
        if (typeof hoverSound !== 'undefined' && hoverSound) {
            hoverSound.volume = 0.6 * mVol * sfVol;
        }
        if (typeof clickSound !== 'undefined' && clickSound) {
            clickSound.volume = 0.7 * mVol * sfVol;
        }
    }
    // Immediately load any saved volume settings when this script executes.
    loadVolumeSettings();

    // Expose volume settings and helpers on the global window so they
    // can be accessed by the pause/options menu script.  Without this
    // assignment the variables would be scoped inside this closure and
    // unavailable to other scripts.
    window.masterVolume = masterVolume;
    window.musicVolume  = musicVolume;
    window.sfxVolume    = sfxVolume;
    window.loadVolumeSettings = loadVolumeSettings;
    window.saveVolumeSettings = saveVolumeSettings;
    window.applyVolumeSettings = applyVolumeSettings;

    // --- Pause and options state ---
    // Track whether the game is currently paused.  These variables are
    // defined outside of any inner functions so that they live for the
    // lifetime of the main game script.  We also expose them on the
    // global window so that the pause/options overlay script can
    // determine whether the pause menu is visible or not without
    // referencing variables that are scoped to this closure.  When
    // showPauseMenu/hidePauseMenu are called the values of isPaused,
    // pauseMenuElement and optionsMenuElement are updated on the
    // window object.  See the pause/options script for how these
    // variables are consumed.
    let isPaused = false;
    let pauseMenuElement;
    let optionsMenuElement;
    // Expose pause state and menu element references on the global
    // window.  These assignments will be kept in sync whenever the
    // pause menu is shown or hidden below.
    window.isPaused = isPaused;
    window.pauseMenuElement = pauseMenuElement;
    window.optionsMenuElement = optionsMenuElement;

    // Icons are generated by rendering miniature 3D previews of each block or tool
    // so the UI reflects how the objects appear in the world.
    function captureIcon(renderer, scene, camera, object) {
        scene.add(object);
        renderer.render(scene, camera);
        const data = renderer.domElement.toDataURL('image/png');
        scene.remove(object);
        return data;
    }

    function createHotbarIcons() {
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(120, 120);
        renderer.setPixelRatio(1);
        renderer.setClearColor(0x000000, 0);
        renderer.outputEncoding = THREE.sRGBEncoding;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(32, 1, 0.1, 10);
        camera.position.set(1.45, 1.1, 1.65);
        camera.lookAt(0, -0.05, 0);

        const ambient = new THREE.AmbientLight(0xffffff, 0.75);
        scene.add(ambient);
        const keyLight = new THREE.DirectionalLight(0xffffff, 1.05);
        keyLight.position.set(2.8, 4.2, 3.5);
        scene.add(keyLight);
        const rimLight = new THREE.DirectionalLight(0xffffff, 0.32);
        rimLight.position.set(-3, -2.4, -1.5);
        scene.add(rimLight);

        const icons = {};
        const previewGeometry = new THREE.BoxGeometry(1, 1, 1);
        const blockTypes = ['grass', 'dirt', 'stone', 'sand', 'wood', 'leaves', 'snow', 'ice', 'moss', 'glowstone', 'cactus'];
        blockTypes.forEach((type) => {
            const baseMat = blockMaterials[type];
            if (!baseMat) return;
            const mat = baseMat.clone();
            mat.side = (type === 'leaves') ? THREE.DoubleSide : THREE.FrontSide;
            mat.depthWrite = true;
            mat.depthTest = true;
            if (type === 'leaves') {
                mat.alphaTest = 0.5;
                mat.transparent = true;
            }
            const mesh = new THREE.Mesh(previewGeometry, mat);
            mesh.scale.set(0.9, 0.9, 0.9);
            mesh.rotation.set(-0.55, Math.PI / 4, 0);
            mesh.position.set(0, -0.08, 0);
            icons[type] = captureIcon(renderer, scene, camera, mesh);
        });

        const toolCaptures = [];
        toolCaptures.push({ type: 'stick', mesh: createStickMesh({ forIcon: true }) });
        TOOL_VARIANTS.forEach((variant) => {
            TOOL_KINDS.forEach((kind) => {
                const factory = TOOL_FACTORIES[kind];
                if (!factory) return;
                toolCaptures.push({ type: `${variant}_${kind}`, mesh: factory({ forIcon: true, variant }) });
            });
        });
        toolCaptures.forEach(({ type, mesh }) => {
            if (!mesh) return;
            const group = new THREE.Group();
            mesh.position.set(0, -0.2, 0);
            mesh.rotation.set(-0.4, -Math.PI / 5, Math.PI / 12);
            mesh.scale.multiplyScalar(1.08);
            group.add(mesh);
            icons[type] = captureIcon(renderer, scene, camera, group);
        });

        renderer.dispose();
        previewGeometry.dispose();
        return icons;
    }

    function refreshAllItemIcons() {
        refreshAllHotbarSlots();
        updateInventoryUI();
        refreshRecipeBookIcons();
        updateCraftingResultUI();
    }

    loadingManager.onLoad = () => {
        hotbarIcons = createHotbarIcons();
        iconsReady = true;
        while (iconReadyCallbacks.length > 0) {
            const cb = iconReadyCallbacks.shift();
            try {
                cb();
            } catch (err) {
                console.warn('Icon ready callback failed', err);
            }
        }
        refreshAllItemIcons();
    };

    const HOTBAR_DRAG_MIME = 'application/x-voxel-item';
    const HOTBAR_STACK_LIMIT = 64;
    const TOOL_TYPES = new Set();
    const ITEM_STACK_LIMITS = {};
    const TOOL_TIER_SPEED = {
        wooden: 0.7,
        stone: 0.55,
        copper: 0.48,
        iron: 0.4,
        diamond: 0.28
    };
    const TOOL_TIER_PENALTY = {
        wooden: 1.28,
        stone: 1.32,
        copper: 1.34,
        iron: 1.36,
        diamond: 1.38
    };
    const TOOL_EFFECTIVE_TYPES = {
        axe: new Set(['wood', 'leaves', 'moss']),
        pickaxe: new Set(['stone', 'iron', 'copper', 'ruby', 'diamond', 'coal', 'moss', 'glowstone']),
        shovel: new Set(['dirt', 'grass', 'sand', 'snow', 'moss']),
        sword: new Set(['leaves', 'moss', 'glowstone'])
    };
    const HEAD_RESOURCE_VARIANT = {
        wood: 'wooden',
        stone: 'stone',
        copper: 'copper',
        iron: 'iron',
        diamond: 'diamond'
    };
    TOOL_VARIANTS.forEach((variant) => {
        TOOL_KINDS.forEach((kind) => {
            const type = `${variant}_${kind}`;
            TOOL_TYPES.add(type);
            ITEM_STACK_LIMITS[type] = 1;
            TOOL_STATS[type] = { kind, tier: variant };
        });
    });
    const VARIANT_HEAD_RESOURCE = {};
    Object.entries(HEAD_RESOURCE_VARIANT).forEach(([resource, variant]) => {
        VARIANT_HEAD_RESOURCE[variant] = resource;
    });

    function isHotbarAssignable(type) {
        return !!type && (blockMaterials[type] || TOOL_TYPES.has(type));
    }

    function setInventoryView(view) {
        if (!view) return;
        activeInventoryView = view;
        const searchView = document.getElementById('inventorySearchView');
        const backpackView = document.getElementById('inventoryBackpackView');
        const searchTab = document.getElementById('inventorySearchTab');
        const backpackTab = document.getElementById('inventoryBackpackTab');
        if (!searchView || !backpackView || !searchTab || !backpackTab) return;
        searchView.classList.toggle('active', view === 'search');
        backpackView.classList.toggle('active', view === 'backpack');
        searchTab.classList.toggle('active', view === 'search');
        backpackTab.classList.toggle('active', view === 'backpack');
        if (view === 'search') {
            const input = document.getElementById('inventorySearch');
            if (input) input.focus();
        } else {
            const input = document.getElementById('inventorySearch');
            if (input) input.blur();
        }
    }

    function initCraftingUI() {
        const gridEl = document.getElementById('craftingGrid');
        const resultEl = document.getElementById('craftingResultSlot');
        if (!gridEl || !resultEl) return;
        gridEl.innerHTML = '';
        for (let i = 0; i < craftingGridState.length; i++) {
            craftingGridState[i] = null;
            const slotEl = document.createElement('div');
            slotEl.className = 'inv-slot craft-slot empty';
            const img = document.createElement('img');
            slotEl.appendChild(img);
            const countSpan = document.createElement('span');
            countSpan.className = 'inv-count';
            slotEl.appendChild(countSpan);

            slotEl.addEventListener('dragover', (event) => {
                if (!canAcceptDraggedItem(event)) return;
                event.preventDefault();
                slotEl.classList.add('drag-over');
                if (event.dataTransfer) event.dataTransfer.dropEffect = 'copy';
            });
            slotEl.addEventListener('dragleave', () => {
                slotEl.classList.remove('drag-over');
            });
            slotEl.addEventListener('drop', (event) => {
                event.preventDefault();
                slotEl.classList.remove('drag-over');
                const type = getDraggedItemType(event);
                if (!type) return;
                const removed = removeItemFromInventory(type, 1);
                if (removed <= 0) return;
                if (!addItemToCraftSlot(i, type, removed)) {
                    addItemToInventory(type, removed);
                }
                recalculateCraftingResult();
            });
            slotEl.addEventListener('click', () => {
                returnCraftingItems(i, 1);
            });
            slotEl.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                returnCraftingItems(i, Infinity);
            });

            gridEl.appendChild(slotEl);
            craftingSlots[i] = { element: slotEl, img, countSpan };
        }

        const resultImg = resultEl.querySelector('img');
        const resultCount = resultEl.querySelector('.inv-count');
        craftingResultSlot = {
            element: resultEl,
            img: resultImg,
            countSpan: resultCount
        };
        resultEl.addEventListener('click', () => {
            applyCraftingResult();
        });
        updateCraftingResultUI();
    }

    function addItemToCraftSlot(index, type, count) {
        if (index < 0 || index >= craftingGridState.length || count <= 0) return false;
        const entry = craftingGridState[index];
        if (entry && entry.type !== type) {
            return false;
        }
        const target = entry || { type, count: 0 };
        target.type = type;
        target.count += count;
        craftingGridState[index] = target;
        updateCraftingSlot(index);
        return true;
    }

    function updateCraftingSlot(index) {
        const slot = craftingSlots[index];
        if (!slot) return;
        const entry = craftingGridState[index];
        if (!entry || entry.count <= 0) {
            craftingGridState[index] = null;
            slot.element.classList.add('empty');
            slot.img.style.display = 'none';
            slot.img.removeAttribute('src');
            slot.countSpan.textContent = '';
            return;
        }
        slot.element.classList.remove('empty');
        if (hotbarIcons[entry.type]) {
            slot.img.style.display = 'block';
            slot.img.src = hotbarIcons[entry.type];
            slot.img.alt = blockNames[entry.type] || entry.type;
        } else {
            if (!iconsReady) {
                onIconsReady(() => updateCraftingSlot(index));
            }
            slot.img.style.display = 'none';
            slot.img.removeAttribute('src');
        }
        slot.countSpan.textContent = entry.count > 1 ? entry.count.toString() : (entry.count === 1 ? '1' : '');
    }

    function returnCraftingItems(index, amount) {
        if (index < 0 || index >= craftingGridState.length) return;
        const entry = craftingGridState[index];
        if (!entry) return;
        const toRemove = amount === Infinity ? entry.count : Math.min(amount, entry.count);
        if (toRemove <= 0) return;
        const added = addItemToInventory(entry.type, toRemove);
        if (added <= 0) return;
        entry.count -= added;
        if (entry.count <= 0) {
            craftingGridState[index] = null;
        }
        updateCraftingSlot(index);
        recalculateCraftingResult();
    }

    function consumeFromCraftSlot(index, amount) {
        if (index < 0 || index >= craftingGridState.length || amount <= 0) return;
        const entry = craftingGridState[index];
        if (!entry) return;
        entry.count -= amount;
        if (entry.count <= 0) {
            craftingGridState[index] = null;
        }
        updateCraftingSlot(index);
    }

    const TOOL_PATTERNS = {
        pickaxe: [
            ['HHH', ' S ', ' S ']
        ],
        axe: [
            ['HH ', 'HS ', ' S '],
            [' HH', ' SH', ' S ']
        ],
        shovel: [
            [' H ', ' S ', ' S ']
        ],
        sword: [
            [' H ', ' H ', ' S ']
        ]
    };
    const TOOL_RECIPE_ORDER = ['pickaxe', 'axe', 'shovel', 'sword'];

    function evaluateToolRecipe(toolKind) {
        const patterns = TOOL_PATTERNS[toolKind];
        if (!patterns || patterns.length === 0) return null;
        for (const pattern of patterns) {
            let headType = null;
            const consumes = [];
            let valid = true;
            for (let row = 0; row < 3 && valid; row++) {
                const rowPattern = pattern[row] || '   ';
                for (let col = 0; col < 3; col++) {
                    const char = rowPattern[col] || ' ';
                    const index = row * 3 + col;
                    const entry = craftingGridState[index];
                    if (char === ' ') {
                        if (entry) { valid = false; break; }
                        continue;
                    }
                    if (!entry || entry.count < 1) { valid = false; break; }
                    if (char === 'H') {
                        const variant = HEAD_RESOURCE_VARIANT[entry.type];
                        if (!variant) { valid = false; break; }
                        if (!headType) headType = entry.type;
                        else if (headType !== entry.type) { valid = false; break; }
                    } else if (char === 'S') {
                        if (entry.type !== 'stick') { valid = false; break; }
                    }
                    consumes.push({ index, count: 1 });
                }
            }
            if (!valid) continue;
            if (!headType) continue;
            const variant = HEAD_RESOURCE_VARIANT[headType];
            if (!variant) continue;
            const resultType = `${variant}_${toolKind}`;
            if (!TOOL_TYPES.has(resultType)) continue;
            const existing = inventory[resultType] || 0;
            if (existing >= getStackLimit(resultType)) continue;
            return { type: resultType, count: 1, consumes };
        }
        return null;
    }

    function evaluateStickRecipe() {
        let totalLogs = 0;
        for (let i = 0; i < craftingGridState.length; i++) {
            const entry = craftingGridState[i];
            if (!entry) continue;
            if (entry.type !== 'wood') return null;
            totalLogs += entry.count;
        }
        if (totalLogs <= 0) return null;
        const availableSpace = Math.max(0, getStackLimit('stick') - (inventory['stick'] || 0));
        if (availableSpace < 4) return null;
        const craftableSets = Math.min(totalLogs, Math.floor(availableSpace / 4));
        if (craftableSets <= 0) return null;
        const consumes = [];
        let remaining = craftableSets;
        for (let i = 0; i < craftingGridState.length && remaining > 0; i++) {
            const entry = craftingGridState[i];
            if (!entry || entry.type !== 'wood') continue;
            const take = Math.min(entry.count, remaining);
            if (take > 0) {
                consumes.push({ index: i, count: take });
                remaining -= take;
            }
        }
        if (consumes.length === 0) return null;
        return {
            type: 'stick',
            count: craftableSets * 4,
            consumes
        };
    }

    function recalculateCraftingResult() {
        currentCraftingResult = null;
        for (const kind of TOOL_RECIPE_ORDER) {
            const result = evaluateToolRecipe(kind);
            if (result) {
                currentCraftingResult = result;
                break;
            }
        }
        if (!currentCraftingResult) {
            currentCraftingResult = evaluateStickRecipe();
        }
        updateCraftingResultUI();
    }

    function updateCraftingResultUI() {
        if (!craftingResultSlot) return;
        const { element, img, countSpan } = craftingResultSlot;
        if (!currentCraftingResult) {
            element.classList.add('empty');
            if (img) {
                img.style.display = 'none';
                img.removeAttribute('src');
            }
            if (countSpan) countSpan.textContent = '';
            return;
        }
        element.classList.remove('empty');
        if (img && hotbarIcons[currentCraftingResult.type]) {
            img.style.display = 'block';
            img.src = hotbarIcons[currentCraftingResult.type];
            img.alt = blockNames[currentCraftingResult.type] || currentCraftingResult.type;
        } else if (img) {
            if (!iconsReady) {
                onIconsReady(() => updateCraftingResultUI());
            }
            img.style.display = 'none';
            img.removeAttribute('src');
        }
        if (countSpan) {
            countSpan.textContent = currentCraftingResult.count > 1 ? currentCraftingResult.count.toString() : '';
        }
    }

    function applyCraftingResult() {
        if (!currentCraftingResult) return;
        const { type, count, consumes } = currentCraftingResult;
        const availableSpace = Math.max(0, getStackLimit(type) - (inventory[type] || 0));
        if (availableSpace <= 0) return;
        const deliverable = Math.min(count, availableSpace);
        if (deliverable <= 0) return;
        const added = addItemToInventory(type, deliverable);
        if (added <= 0) return;
        consumes.forEach(({ index, count: consumeCount }) => {
            consumeFromCraftSlot(index, consumeCount);
        });
        recalculateCraftingResult();
    }

    function getStackLimit(type) {
        if (!type) return HOTBAR_STACK_LIMIT;
        return ITEM_STACK_LIMITS[type] || HOTBAR_STACK_LIMIT;
    }

    // Human readable names for each block type.  These are used in the
    // selection tooltip shown when switching slots.
    const blockNames = {
        grass: 'Grass',
        dirt: 'Dirt',
        stone: 'Stone',
        wood: 'Wood',
        leaves: 'Leaves',
        sand: 'Sand',
        water: 'Water',
        bedrock: 'Bedrock',
        snow: 'Snow',
        ice: 'Ice',
        moss: 'Mossy Stone',
        glowstone: 'Glowstone',
        cactus: 'Cactus',
        iron: 'Iron Ore',
        copper: 'Copper Ore',
        ruby: 'Ruby Crystal',
        diamond: 'Diamond',
        coal: 'Coal Ore',
        lava: 'Lava',
        stick: 'Sticks'
    };
    TOOL_VARIANTS.forEach((variant) => {
        TOOL_KINDS.forEach((kind) => {
            const type = `${variant}_${kind}`;
            blockNames[type] = `${TOOL_VARIANT_LABELS[variant]} ${TOOL_KIND_LABELS[kind]}`;
        });
    });
    const BLOCK_TYPE_ORDER = Object.keys(blockNames);

    const recipeBookEntries = [
        {
            id: 'stick',
            name: 'Stick Bundle',
            result: { type: 'stick', label: 'Makes 4 sticks per log', shortLabel: '√ó4' },
            listLabel: '√ó4',
            summary: 'Split raw logs into sticks ready for future crafting recipes.',
            pattern: [
                ['wood', null, null],
                ['wood', null, null],
                [null, null, null]
            ],
            patternNote: 'Logs can be placed in any slot; each log converts into four sticks (two logs yield eight).',
            steps: [
                'Place one log into any crafting grid slot.',
                'Collect four sticks from the result slot.',
                'Add a second log before collecting to craft eight sticks at once.'
            ],
            note: 'Keep a reserve of sticks for tools, torches, and other recipes.'
        }
    ];
    const TOOL_RECIPE_TEXT = {
        pickaxe: {
            summary: (variantLabel) => `Build a ${variantLabel} Pickaxe that tears through stone and ore nodes.`,
            steps: [
                (_variant, _tool, material) => `Lay three ${material} blocks across the top row.`,
                () => 'Place sticks in the centre of the middle and bottom rows.',
                (variantLabel, toolLabel) => `Collect the ${variantLabel} ${toolLabel} from the output slot.`
            ]
        },
        axe: {
            summary: (variantLabel) => `Craft a ${variantLabel} Axe to bite through tree trunks with ease.`,
            steps: [
                (_variant, _tool, material) => `Arrange ${material} blocks in an L shape matching the diagram.`,
                () => 'Stack sticks down the handle column.',
                (variantLabel, toolLabel) => `Pick up the ${variantLabel} ${toolLabel} once the pattern is complete.`
            ]
        },
        shovel: {
            summary: (variantLabel) => `Shape a ${variantLabel} Shovel for rapid digging through soil and sand.`,
            steps: [
                (_variant, _tool, material) => `Place one ${material} block at the top centre.`,
                () => 'Set sticks in the middle column beneath it.',
                (variantLabel, toolLabel) => `Grab the ${variantLabel} ${toolLabel} from the result slot.`
            ]
        },
        sword: {
            summary: (variantLabel) => `Forge a ${variantLabel} Sword for close combat and foliage cutting.`,
            steps: [
                (_variant, _tool, material) => `Stack two ${material} blocks in the centre column.`,
                () => 'Add a stick beneath them to form the grip.',
                (variantLabel, toolLabel) => `Claim the ${variantLabel} ${toolLabel} from the output.`
            ]
        }
    };
    TOOL_VARIANTS.forEach((variant) => {
        const material = VARIANT_HEAD_RESOURCE[variant];
        if (!material) return;
        const materialLabel = (blockNames[material] || material).toLowerCase();
        const variantLabel = TOOL_VARIANT_LABELS[variant];
        const resourceLabel = blockNames[material] || material;
        TOOL_KINDS.forEach((kind) => {
            const type = `${variant}_${kind}`;
            if (!TOOL_TYPES.has(type)) return;
            const toolLabel = TOOL_KIND_LABELS[kind];
            const text = TOOL_RECIPE_TEXT[kind];
            if (!text) return;
            const summary = text.summary(variantLabel);
            const steps = text.steps.map((fn) => fn(variantLabel, toolLabel, materialLabel));
            const patternTemplate = TOOL_PATTERNS[kind] && TOOL_PATTERNS[kind][0];
            if (!patternTemplate) return;
            const pattern = patternTemplate.map((row) => {
                return (row || '   ').split('').map((char) => {
                    if (char === 'H') return material;
                    if (char === 'S') return 'stick';
                    return null;
                });
            });
            const entry = {
                id: type,
                name: `${variantLabel} ${toolLabel}`,
                result: { type, label: `Creates one ${variantLabel.toLowerCase()} ${toolLabel.toLowerCase()}`, shortLabel: '√ó1' },
                listLabel: '√ó1',
                summary,
                pattern,
                steps
            };
            if (kind === 'axe') {
                entry.patternNote = 'Pattern works mirrored‚Äîflip the head to craft left- or right-handed axes.';
            }
            if (variant !== 'wooden') {
                entry.note = `Mine ${resourceLabel.toLowerCase()} to unlock this ${toolLabel.toLowerCase()} recipe.`;
            }
            recipeBookEntries.push(entry);
        });
    });
    let activeRecipeId = null;

    function setRecipeBookOpen(open) {
        const panel = document.getElementById('recipeBookPanel');
        const toggle = document.getElementById('recipeBookToggle');
        if (!panel || !toggle) return;
        if (open) {
            panel.classList.add('open');
            panel.hidden = false;
            toggle.classList.add('active');
            toggle.setAttribute('aria-expanded', 'true');
        } else {
            panel.classList.remove('open');
            panel.hidden = true;
            toggle.classList.remove('active');
            toggle.setAttribute('aria-expanded', 'false');
        }
    }

    function setRecipeBookActive(recipeId) {
        const list = document.getElementById('recipeBookList');
        const detail = document.getElementById('recipeBookDetail');
        if (!list || !detail) return;
        if (!recipeId) {
            activeRecipeId = null;
            detail.classList.add('empty');
            detail.textContent = 'Select a recipe to view crafting steps.';
            list.querySelectorAll('.recipe-entry').forEach((btn) => btn.classList.remove('active'));
            return;
        }
        const recipe = recipeBookEntries.find((entry) => entry.id === recipeId);
        if (!recipe) return;
        activeRecipeId = recipeId;
        list.querySelectorAll('.recipe-entry').forEach((btn) => {
            btn.classList.toggle('active', btn.dataset.recipeId === recipeId);
        });
        detail.classList.remove('empty');
        detail.innerHTML = '';

        const header = document.createElement('div');
        header.className = 'recipe-detail-header';

        const iconWrap = document.createElement('div');
        iconWrap.className = 'recipe-detail-icon';
        const icon = document.createElement('img');
        icon.draggable = false;
        const iconSrc = recipe.result && recipe.result.type ? hotbarIcons[recipe.result.type] : '';
        if (iconSrc) {
            icon.src = iconSrc;
        } else {
            icon.style.display = 'none';
            if (!iconsReady) {
                onIconsReady(() => setRecipeBookActive(recipeId));
            }
        }
        icon.alt = recipe.result && recipe.result.type ? (blockNames[recipe.result.type] || recipe.result.type) : recipe.name;
        iconWrap.appendChild(icon);
        header.appendChild(iconWrap);

        const headerText = document.createElement('div');
        headerText.className = 'recipe-detail-text';
        const title = document.createElement('div');
        title.className = 'recipe-detail-title';
        title.textContent = recipe.name;
        headerText.appendChild(title);
        if (recipe.result && recipe.result.label) {
            const output = document.createElement('div');
            output.className = 'recipe-detail-output';
            output.textContent = recipe.result.label;
            headerText.appendChild(output);
        }
        header.appendChild(headerText);
        detail.appendChild(header);

        if (recipe.summary) {
            const summary = document.createElement('p');
            summary.className = 'recipe-detail-summary';
            summary.textContent = recipe.summary;
            detail.appendChild(summary);
        }

        if (recipe.pattern) {
            const visual = document.createElement('div');
            visual.className = 'recipe-pattern-visual';
            const grid = document.createElement('div');
            grid.className = 'recipe-pattern-grid';
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'recipe-cell';
                    const type = recipe.pattern[row] ? recipe.pattern[row][col] : null;
                    if (type) {
                        if (hotbarIcons[type]) {
                            const img = document.createElement('img');
                            img.src = hotbarIcons[type];
                            img.alt = blockNames[type] || type;
                            img.draggable = false;
                            cell.appendChild(img);
                        } else {
                            cell.textContent = blockNames[type] || type;
                            if (!iconsReady) {
                                onIconsReady(() => setRecipeBookActive(recipeId));
                            }
                        }
                    } else {
                        cell.classList.add('empty');
                    }
                    grid.appendChild(cell);
                }
            }
            visual.appendChild(grid);

            const arrow = document.createElement('div');
            arrow.className = 'recipe-arrow';
            arrow.textContent = '‚ûú';
            visual.appendChild(arrow);

            const resultWrap = document.createElement('div');
            resultWrap.className = 'recipe-result';
            if (recipe.result && recipe.result.type && hotbarIcons[recipe.result.type]) {
                const resultIcon = document.createElement('img');
                resultIcon.src = hotbarIcons[recipe.result.type];
                resultIcon.alt = blockNames[recipe.result.type] || recipe.result.type;
                resultIcon.draggable = false;
                resultWrap.appendChild(resultIcon);
            } else if (recipe.result && recipe.result.type && !iconsReady) {
                onIconsReady(() => setRecipeBookActive(recipeId));
            }
            if (recipe.result && recipe.result.shortLabel) {
                const count = document.createElement('div');
                count.className = 'recipe-result-count';
                count.textContent = recipe.result.shortLabel;
                resultWrap.appendChild(count);
            }
            visual.appendChild(resultWrap);
            detail.appendChild(visual);

            if (recipe.patternNote) {
                const patternNote = document.createElement('p');
                patternNote.className = 'recipe-detail-note';
                patternNote.textContent = recipe.patternNote;
                detail.appendChild(patternNote);
            }
        }

        if (recipe.steps && recipe.steps.length > 0) {
            const stepsList = document.createElement('ol');
            stepsList.className = 'recipe-steps';
            recipe.steps.forEach((step) => {
                const li = document.createElement('li');
                li.textContent = step;
                stepsList.appendChild(li);
            });
            detail.appendChild(stepsList);
        }

        if (recipe.note) {
            const note = document.createElement('p');
            note.className = 'recipe-detail-note';
            note.textContent = recipe.note;
            detail.appendChild(note);
        }
    }

    function initRecipeBookUI() {
        const list = document.getElementById('recipeBookList');
        const toggle = document.getElementById('recipeBookToggle');
        const panel = document.getElementById('recipeBookPanel');
        if (!list || !toggle || !panel) return;

        list.innerHTML = '';
        recipeBookEntries.forEach((recipe) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'recipe-entry';
            button.dataset.recipeId = recipe.id;

            const iconWrap = document.createElement('span');
            iconWrap.className = 'recipe-entry-icon';
            const icon = document.createElement('img');
            icon.draggable = false;
            if (recipe.result && recipe.result.type && hotbarIcons[recipe.result.type]) {
                icon.src = hotbarIcons[recipe.result.type];
            } else {
                icon.style.display = 'none';
                if (!iconsReady) {
                    onIconsReady(() => refreshRecipeBookIcons());
                }
            }
            icon.alt = recipe.result && recipe.result.type ? (blockNames[recipe.result.type] || recipe.result.type) : recipe.name;
            iconWrap.appendChild(icon);
            button.appendChild(iconWrap);

            const name = document.createElement('span');
            name.className = 'recipe-entry-name';
            name.textContent = recipe.name;
            button.appendChild(name);

            if (recipe.listLabel) {
                const output = document.createElement('span');
                output.className = 'recipe-entry-output';
                output.textContent = recipe.listLabel;
                button.appendChild(output);
            }

            button.addEventListener('click', () => {
                setRecipeBookActive(recipe.id);
            });

            list.appendChild(button);
        });

        setRecipeBookOpen(false);
        setRecipeBookActive(null);

        toggle.addEventListener('click', () => {
            const willOpen = !panel.classList.contains('open');
            setRecipeBookOpen(willOpen);
            if (willOpen && !activeRecipeId && recipeBookEntries.length > 0) {
                setRecipeBookActive(recipeBookEntries[0].id);
            }
        });
    }

    function refreshRecipeBookIcons() {
        const list = document.getElementById('recipeBookList');
        if (list) {
            list.querySelectorAll('.recipe-entry').forEach((btn) => {
                const recipeId = btn.dataset.recipeId;
                const recipe = recipeBookEntries.find((entry) => entry.id === recipeId);
                if (!recipe) return;
                const img = btn.querySelector('.recipe-entry-icon img');
                if (!img) return;
                if (recipe.result && recipe.result.type && hotbarIcons[recipe.result.type]) {
                    img.style.display = 'block';
                    img.src = hotbarIcons[recipe.result.type];
                    img.alt = blockNames[recipe.result.type] || recipe.result.type;
                } else {
                    img.style.display = 'none';
                    img.removeAttribute('src');
                }
            });
        }
        if (activeRecipeId) {
            setRecipeBookActive(activeRecipeId);
        }
    }

    // Tooltip element shown above the selected hotbar slot.  The element
    // itself is created in the HTML; we reference it here and control its
    // visibility and position.  A timeout ID is stored to hide the
    // tooltip after a delay.
    let selectionTooltip;
    let tooltipTimeout = null;

    // --- Audio and step sound state ---
    // A listener is attached to the camera so that positional audio (if desired) will
    // follow the player's head.  Step sounds are loaded and stored in this
    // array.  lastStepSoundTime tracks when the last step sound was played so
    // that we don't spam sounds while the player is moving.  wasOnGround
    // remembers whether the player was previously grounded so we can detect
    // landing events.
    let audioListener;
    const stepSounds = [];
    let lastStepSoundTime = 0;
    let wasOnGround = true;

    // --- Health and damage state ---
    // The player has a finite amount of health represented by hearts.  Five
    // hearts correspond to five hit points.  Health is decreased when
    // falling from a height or when in contact with lava.  When health
    // reaches zero the player dies and a death screen appears.  fallDistance
    // accumulates the distance fallen since the last time the player was on
    // the ground.  lastY stores the player's height from the previous
    // frame.  Damage sounds are loaded in init().
    let maxHealth = 5;
    let health = maxHealth;
    let fallDistance = 0;
    let lastYPosition = 0;
    const damageSounds = [];
    let deathSound;
    // Accumulator for lava damage.  When the player stands in lava this
    // value increases with time and triggers periodic damage.  It resets
    // when the player leaves lava.
    let lavaAccumulator = 0;

    // Music playback state.  The tracks listed here are the Minecraft in‚Äëgame
    // music tracks that will play in a random order.  music and musicLoader
    // hold the audio objects used for background music.  musicStarted
    // ensures that music begins playing only once after user interaction.
    const MUSIC_TRACKS = [
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/endless.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/a_familiar_room.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/an_ordinary_day.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/ancestry.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/bromeliad.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/clark.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/comforting_memories.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/crescent_dunes.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/danny.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/deeper.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/dry_hands.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/echo_in_the_wind.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/eld_unknown.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/featherfall.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/floating_dream.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/haggstrom.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/infinite_amethyst.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/key.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/komorebi.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/left_to_bloom.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/yakusoku.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/wet_hands.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/wending.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/watcher.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/sweden.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/subwoofer_lullaby.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/stand_tall.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/puzzlebox.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/pokopoko.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/oxygene.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/one_more_day.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/minecraft.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/mice_on_venus.ogg',
        'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/music/game/living_mice.ogg'
    ];
    let music;
    let musicLoader;
    let musicStarted = false;

    // --- RNG + Perlin noise (unchanged) ---
    function mulberry32(a) {
        return function() {
            let t = a += 0x6D2B79F5;
            t = Math.imul(t ^ (t >>> 15), t | 1);
            t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        }
    }
    function createPerlin(seedValue) {
        const rand = mulberry32(seedValue | 0);
        const p = new Uint8Array(512);
        const permutation = new Uint8Array(256);
        for (let i = 0; i < 256; i++) permutation[i] = i;
        for (let i = 255; i > 0; i--) {
            const j = Math.floor(rand() * (i + 1));
            const tmp = permutation[i];
            permutation[i] = permutation[j];
            permutation[j] = tmp;
        }
        for (let i = 0; i < 512; i++) p[i] = permutation[i & 255];
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        function rawNoise(x, y, z) {
            let X = Math.floor(x) & 255;
            let Y = Math.floor(y) & 255;
            let Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            const u = fade(x), v = fade(y), w = fade(z);
            const A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z;
            const B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;
            return lerp(w,
                lerp(v,
                    lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)),
                    lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))
                ),
                lerp(v,
                    lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)),
                    lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1))
                )
            );
        }
        return function(x, z, octaves = OCTAVES, persistence = PERSISTENCE, frequency = WORLD_FREQUENCY) {
            let total = 0, amplitude = 1, maxValue = 0, freq = frequency;
            for (let i = 0; i < octaves; i++) {
                total += rawNoise(x * freq, 0, z * freq) * amplitude;
                maxValue += amplitude;
                amplitude *= persistence;
                freq *= 2;
            }
            return total / maxValue;
        };
    }
    function createPerlin3D(seedValue) {
        const rand = mulberry32(seedValue | 0);
        const p = new Uint8Array(512);
        const permutation = new Uint8Array(256);
        for (let i = 0; i < 256; i++) permutation[i] = i;
        for (let i = 255; i > 0; i--) {
            const j = Math.floor(rand() * (i + 1));
            const tmp = permutation[i];
            permutation[i] = permutation[j];
            permutation[j] = tmp;
        }
        for (let i = 0; i < 512; i++) p[i] = permutation[i & 255];
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        function rawNoise(x, y, z) {
            let X = Math.floor(x) & 255;
            let Y = Math.floor(y) & 255;
            let Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            const u = fade(x), v = fade(y), w = fade(z);
            const A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z;
            const B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;
            return lerp(w,
                lerp(v,
                    lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)),
                    lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))
                ),
                lerp(v,
                    lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)),
                    lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1))
                )
            );
        }
        return function(x, y, z, octaves = 4, persistence = 0.5, frequency = 0.05) {
            let total = 0, amplitude = 1, maxValue = 0, freq = frequency;
            for (let i = 0; i < octaves; i++) {
                total += rawNoise(x * freq, y * freq, z * freq) * amplitude;
                maxValue += amplitude;
                amplitude *= persistence;
                freq *= 2;
            }
            return total / maxValue;
        };
    }
    const BIOME_FREQUENCY = 0.008;
    const DEFAULT_FOG_RANGE = { near: 120, far: 320 };
    const BIOME_SETTINGS = {
        meadow: {
            key: 'meadow',
            name: 'Luminous Meadow',
            surface: 'grass',
            underwaterSurface: 'sand',
            subsurface: 'dirt',
            deep: 'stone',
            soilLayers: DIRT_LAYERS,
            treeType: 'oak',
            treeChance: 0.035,
            decorations: { moss: 0.05 },
            heightOffset: 0,
            fogNear: 110,
            fogFar: 320,
            skyTint: 0x9fd3ff,
            ambientBoost: 0.02
        },
        desert: {
            key: 'desert',
            name: 'Sunstone Desert',
            surface: 'sand',
            underwaterSurface: 'sand',
            subsurface: 'sand',
            deep: 'stone',
            soilLayers: 1,
            treeType: 'cactus',
            treeChance: 0.05,
            decorations: {},
            heightOffset: -1,
            fogNear: 130,
            fogFar: 360,
            skyTint: 0xf2d7a2,
            ambientBoost: 0
        },
        taiga: {
            key: 'taiga',
            name: 'Frostpine Taiga',
            surface: 'snow',
            underwaterSurface: 'stone',
            subsurface: 'dirt',
            deep: 'stone',
            soilLayers: 2,
            treeType: 'pine',
            treeChance: 0.05,
            decorations: { moss: 0.02 },
            heightOffset: 2,
            fogNear: 80,
            fogFar: 260,
            skyTint: 0xd8f0ff,
            ambientBoost: -0.02,
            freezeWater: true
        },
        tundra: {
            key: 'tundra',
            name: 'Polar Tundra',
            surface: 'snow',
            underwaterSurface: 'stone',
            subsurface: 'stone',
            deep: 'stone',
            soilLayers: 1,
            treeType: null,
            treeChance: 0,
            decorations: {},
            heightOffset: 1,
            fogNear: 70,
            fogFar: 220,
            skyTint: 0xe5effa,
            ambientBoost: -0.03,
            freezeWater: true
        },
        rainforest: {
            key: 'rainforest',
            name: 'Emerald Rainforest',
            surface: 'grass',
            underwaterSurface: 'dirt',
            subsurface: 'dirt',
            deep: 'stone',
            soilLayers: 4,
            treeType: 'oak',
            treeChance: 0.07,
            decorations: { moss: 0.12, glowstone: 0.02 },
            heightOffset: 1,
            fogNear: 60,
            fogFar: 200,
            skyTint: 0x83d8b0,
            ambientBoost: 0.08
        },
        crystal: {
            key: 'crystal',
            name: 'Crystal Wilds',
            surface: 'moss',
            underwaterSurface: 'stone',
            subsurface: 'stone',
            deep: 'stone',
            soilLayers: 2,
            treeType: 'glowshroom',
            treeChance: 0.08,
            decorations: { glowstone: 0.18 },
            heightOffset: -1,
            fogNear: 70,
            fogFar: 220,
            skyTint: 0x7ad8ff,
            ambientBoost: 0.1,
            glowstoneInStone: 0.02
        },
        skylands: {
            key: 'skylands',
            name: 'Skybloom Isles',
            surface: 'moss',
            underwaterSurface: 'stone',
            subsurface: 'stone',
            deep: 'stone',
            soilLayers: 2,
            treeType: 'glowshroom',
            treeChance: 0.06,
            decorations: { glowstone: 0.12 },
            heightOffset: 3,
            fogNear: 85,
            fogFar: 260,
            skyTint: 0xc1f4ff,
            ambientBoost: 0.06,
            skyIslands: true,
            glowstoneInStone: 0.015
        }
    };
    function sampleBiomeNoise(noiseFn, x, z, freq) {
        if (!noiseFn) return 0.5;
        return (noiseFn(x, z, 3, 0.5, freq) + 1) / 2;
    }
    function computeBiome(x, z) {
        const heat = sampleBiomeNoise(heatNoise, x, z, BIOME_FREQUENCY);
        const moisture = sampleBiomeNoise(moistureNoise, x, z, BIOME_FREQUENCY);
        const mystic = sampleBiomeNoise(mysticNoise, x, z, BIOME_FREQUENCY * 0.7);
        const skyVal = sampleBiomeNoise(skyIslandNoise, x, z, BIOME_FREQUENCY * 0.5);
        let key = 'meadow';
        if (skyVal > 0.84 && heat > 0.4) {
            key = 'skylands';
        } else if (mystic > 0.78 && moisture > 0.55) {
            key = 'crystal';
        } else if (heat > 0.7 && moisture < 0.35) {
            key = 'desert';
        } else if (heat < 0.28 && moisture > 0.55) {
            key = 'taiga';
        } else if (heat < 0.25 && moisture < 0.5) {
            key = 'tundra';
        } else if (moisture > 0.72) {
            key = 'rainforest';
        }
        const base = BIOME_SETTINGS[key] || BIOME_SETTINGS.meadow;
        return { ...base, samples: { heat, moisture, mystic, sky: skyVal } };
    }
    function getBiomeAt(x, z) {
        const ix = Math.floor(x);
        const iz = Math.floor(z);
        const key = `${ix},${iz}`;
        if (biomeCache.has(key)) return biomeCache.get(key);
        const biome = computeBiome(ix, iz);
        biomeCache.set(key, biome);
        return biome;
    }
    // Deterministic helper for tree placement
    function coordSeededRand(cx, cz, wx, wz) {
        const s = (seed ^ (cx*73856093) ^ (cz*19349663) ^ (wx*83492791) ^ (wz*1234567)) >>> 0;
        return mulberry32(s);
    }

    // --- Chunk generation ---
    function generateChunk(cx, cz) {
        const chunkKeyString = `${cx},${cz}`;
        const heights = {};
        const columnBiomes = new Map();
        const worldX0 = cx * CHUNK_SIZE;
        const worldZ0 = cz * CHUNK_SIZE;
        // Compute height map for this chunk (with border for neighbours)
        for (let dx = -1; dx <= CHUNK_SIZE; dx++) {
            for (let dz = -1; dz <= CHUNK_SIZE; dz++) {
                const wx = worldX0 + dx;
                const wz = worldZ0 + dz;
                const biome = getBiomeAt(wx, wz);
                columnBiomes.set(`${wx},${wz}`, biome);
                const continentNoise = (perlinNoise(wx, wz, 4, 0.5, WORLD_FREQUENCY * 0.22) + 1) / 2;
                const ridgeNoise = (perlinNoise(wx, wz, 5, 0.5, WORLD_FREQUENCY * 0.9) + 1) / 2;
                const detailNoise = (perlinNoise(wx, wz, 3, 0.55, WORLD_FREQUENCY * 1.6) + 1) / 2;
                const mountainNoise = Math.pow(ridgeNoise, 1.6);
                let normalized = continentNoise * 0.52 + mountainNoise * 0.34 + detailNoise * 0.14;
                const plateauNoise = (perlinNoise(wx, wz, 2, 0.6, WORLD_FREQUENCY * 0.12) + 1) / 2;
                if (plateauNoise > 0.58) {
                    const strength = Math.min(1, (plateauNoise - 0.58) / 0.42);
                    const flatTarget = Math.round(normalized * 12) / 12;
                    normalized = THREE.MathUtils.lerp(normalized, flatTarget, strength * 0.7);
                }
                const flattenMask = (perlinNoise(wx, wz, 3, 0.6, PLAINS_MASK_FREQUENCY) + 1) / 2;
                const flatTarget = PLAINS_BASE + continentNoise * PLAINS_VARIATION;
                const isMeadowy = biome && (biome.key === 'meadow' || biome.key === 'desert');
                let flattenStrength = 0;
                if (flattenMask > PLAINS_THRESHOLD) {
                    flattenStrength = Math.min(1, (flattenMask - PLAINS_THRESHOLD) / (1 - PLAINS_THRESHOLD));
                }
                if (isMeadowy) {
                    flattenStrength = Math.max(flattenStrength, 0.45);
                }
                if (flattenStrength > 0) {
                    normalized = THREE.MathUtils.lerp(normalized, flatTarget, flattenStrength * 0.85);
                }
                normalized = THREE.MathUtils.clamp(normalized, 0, 1);
                let h = Math.floor(normalized * (CHUNK_HEIGHT - 12)) + 4;
                const oceanNoise = (perlinNoise(wx, wz, 3, 0.55, OCEAN_MASK_FREQUENCY) + 1) / 2;
                if (oceanNoise < OCEAN_THRESHOLD) {
                    const denom = Math.max(OCEAN_SHELF_BLEND, 0.0001);
                    const shelfFactor = Math.min(1, Math.max(0, (OCEAN_THRESHOLD - oceanNoise) / denom));
                    const depthStrength = Math.pow((OCEAN_THRESHOLD - oceanNoise) / OCEAN_THRESHOLD, 1.2);
                    const floorNoise = (perlinNoise(wx, wz, 2, 0.55, WORLD_FREQUENCY * 1.8) + 1) / 2;
                    const depth = OCEAN_MAX_DEPTH * (0.35 + 0.65 * depthStrength) * shelfFactor;
                    const floorOffset = Math.round(floorNoise * OCEAN_FLOOR_JITTER);
                    const oceanFloor = Math.floor(WATER_LEVEL - 2 - depth - floorOffset);
                    h = Math.min(h, oceanFloor);
                }
                if (biome && typeof biome.heightOffset === 'number') {
                    h += biome.heightOffset;
                }
                h = Math.max(0, Math.min(CHUNK_HEIGHT - 1, h));
                heights[`${wx},${wz}`] = h;
                // Update global height map if this column is higher than previous
                const key = `${wx},${wz}`;
                if (heightMap[key] === undefined || h > heightMap[key]) {
                    heightMap[key] = h;
                }
            }
        }
        // Determine cave entrances for this chunk.  A small chance per column
        // spawns an entrance centre; a circular area around the centre is
        // carved out to form the opening.  Entrance cells are stored in a
        // set keyed by "x,z".  We update the global height map to reflect
        // the lowered surface at these locations so the player can fall
        // naturally into the hole.
        const entranceCells = new Set();
        for (let lx = 0; lx < CHUNK_SIZE; lx++) {
            for (let lz = 0; lz < CHUNK_SIZE; lz++) {
                const wx = worldX0 + lx;
                const wz = worldZ0 + lz;
                const colKey = `${wx},${wz}`;
                const colHeight = heights[colKey];
                // Only spawn entrances on columns that are sufficiently above the water level.
                // Use the constant 4 (default water level) directly here because
                // waterLevel has not yet been defined in this scope at runtime.
                if (colHeight > 4 + 2) {
                    const rSeed = (seed ^ (wx * 897689) ^ (wz * 354331) ^ 0xCAFEBABE) >>> 0;
                    const rng = mulberry32(rSeed);
                    if (rng() < ENTRANCE_CHANCE) {
                        for (let dx = -ENTRANCE_RADIUS; dx <= ENTRANCE_RADIUS; dx++) {
                            for (let dz = -ENTRANCE_RADIUS; dz <= ENTRANCE_RADIUS; dz++) {
                                if (dx*dx + dz*dz <= ENTRANCE_RADIUS * ENTRANCE_RADIUS) {
                                    const ex = wx + dx;
                                    const ez = wz + dz;
                                    entranceCells.add(`${ex},${ez}`);
                                    // Reduce the heightMap for the entrance cell so the
                                    // player can fall down.  Ensure we don't drop below 0.
                                    const eKey = `${ex},${ez}`;
                                    const hVal = heights[eKey];
                                    if (hVal !== undefined) {
                                        const newH = Math.max(0, hVal - ENTRANCE_DEPTH);
                                        // Only update if this column is part of this chunk; heightMap
                                        // is keyed by world x,z and updated here.
                                        if (heightMap[eKey] === undefined || heightMap[eKey] > newH) {
                                            heightMap[eKey] = newH;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Matrix lists and world coordinate lists for instanced meshes
        // Each block type gets its own array of matrices and positions.  Be sure to
        // include entries for all possible block types, including ores and
        // lava, otherwise pushes into undefined arrays will throw errors.
        const matrices = {
            grass: [], dirt: [], stone: [], sand: [], water: [], wood: [], leaves: [], bedrock: [],
            snow: [], ice: [], moss: [], glowstone: [], cactus: [],
            iron: [], copper: [], ruby: [], diamond: [], coal: [], lava: []
        };
        const positionsByType = {
            grass: [], dirt: [], stone: [], sand: [], water: [], wood: [], leaves: [], bedrock: [],
            snow: [], ice: [], moss: [], glowstone: [], cactus: [],
            iron: [], copper: [], ruby: [], diamond: [], coal: [], lava: []
        };
        const waterCells = [];
        // Helper to queue a block into the instancing buffers while keeping
        // voxelMap and the height map in sync.
        function queueBlock(type, x, y, z) {
            if (y < 0 || y >= CHUNK_HEIGHT) return;
            const key = `${x},${y},${z}`;
            voxelMap.set(key, { type, chunk: chunkKeyString });
            if (type === 'water') {
                waterCells.push({ x, y, z });
                positionsByType.water.push({ x, y, z });
                return;
            }
            if (!matrices[type]) return;
            const m = new THREE.Matrix4();
            m.makeTranslation(x + 0.5, y + 0.5, z + 0.5);
            matrices[type].push(m);
            positionsByType[type].push({ x, y, z });
            if (type !== 'water' && type !== 'leaves' && type !== 'lava') {
                const colKey = `${x},${z}`;
                if (heightMap[colKey] === undefined || y > heightMap[colKey]) {
                    heightMap[colKey] = y;
                }
            }
        }
        function growTree(type, baseX, baseY, baseZ, biome) {
            const rng = coordSeededRand(cx, cz, baseX, baseZ);
            const next = () => rng();
            if (type === 'oak') {
                const trunkH = 4 + Math.floor(next() * 3);
                for (let t = 0; t < trunkH; t++) {
                    queueBlock('wood', baseX, baseY + t, baseZ);
                }
                const topY = baseY + trunkH - 1;
                for (let lx = -2; lx <= 2; lx++) {
                    for (let lz = -2; lz <= 2; lz++) {
                        for (let ly = 0; ly <= 2; ly++) {
                            if (Math.abs(lx) === 2 && Math.abs(lz) === 2 && ly === 2) continue;
                            const leafX = baseX + lx;
                            const leafY = topY + ly;
                            const leafZ = baseZ + lz;
                            const key = `${leafX},${leafY},${leafZ}`;
                            if (!voxelMap.has(key)) queueBlock('leaves', leafX, leafY, leafZ);
                        }
                    }
                }
            } else if (type === 'pine') {
                const trunkH = 5 + Math.floor(next() * 4);
                for (let t = 0; t < trunkH; t++) {
                    queueBlock('wood', baseX, baseY + t, baseZ);
                }
                const topY = baseY + trunkH;
                for (let i = 0; i < 4; i++) {
                    const radius = Math.max(1, 3 - i);
                    const y = topY - i;
                    for (let lx = -radius; lx <= radius; lx++) {
                        for (let lz = -radius; lz <= radius; lz++) {
                            if (Math.abs(lx) + Math.abs(lz) > radius + 1) continue;
                            const leafX = baseX + lx;
                            const leafY = y;
                            const leafZ = baseZ + lz;
                            const key = `${leafX},${leafY},${leafZ}`;
                            if (!voxelMap.has(key)) queueBlock('leaves', leafX, leafY, leafZ);
                        }
                    }
                }
                queueBlock('leaves', baseX, topY + 1, baseZ);
            } else if (type === 'cactus') {
                const height = 3 + Math.floor(next() * 3);
                for (let t = 0; t < height; t++) {
                    queueBlock('cactus', baseX, baseY + t, baseZ);
                }
            } else if (type === 'glowshroom') {
                const stem = 3 + Math.floor(next() * 2);
                for (let t = 0; t < stem; t++) {
                    queueBlock('moss', baseX, baseY + t, baseZ);
                }
                const capY = baseY + stem;
                for (let lx = -2; lx <= 2; lx++) {
                    for (let lz = -2; lz <= 2; lz++) {
                        const distSq = lx*lx + lz*lz;
                        if (distSq <= 4) {
                            queueBlock('glowstone', baseX + lx, capY, baseZ + lz);
                        }
                        if (distSq <= 2) {
                            queueBlock('glowstone', baseX + lx, capY + 1, baseZ + lz);
                        }
                    }
                }
                if (biome && biome.key === 'skylands') {
                    queueBlock('glowstone', baseX, capY - 1, baseZ);
                }
            }
        }
        function spawnSkyIsland(centerX, centerZ, groundHeight, strength) {
            const radius = 3 + Math.floor(strength * 4);
            const islandY = Math.min(CHUNK_HEIGHT - 6, groundHeight + 10 + Math.floor(strength * 12));
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dz = -radius; dz <= radius; dz++) {
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist > radius) continue;
                    const peakOffset = Math.round((1 - dist / radius) * 3);
                    const topY = islandY + peakOffset;
                    for (let yy = topY; yy >= topY - 3; yy--) {
                        const blockType = (yy === topY) ? 'moss' : (yy >= topY - 1 ? 'dirt' : 'stone');
                        queueBlock(blockType, centerX + dx, yy, centerZ + dz);
                    }
                    const hangSeed = coordSeededRand(cx, cz, centerX + dx, centerZ + dz)();
                    if (hangSeed > 0.82) {
                        const hangLength = 1 + Math.floor(hangSeed * 3);
                        for (let i = 1; i <= hangLength; i++) {
                            const y = topY - 3 - i;
                            if (y <= 0) break;
                            queueBlock(i === hangLength ? 'glowstone' : 'stone', centerX + dx, y, centerZ + dz);
                        }
                    }
                }
            }
        }
        // Use the global WATER_LEVEL constant instead of a hardcoded value.
        const waterLevel = WATER_LEVEL;
        // For each column generate terrain, trees, water and bedrock
        for (let lx = 0; lx < CHUNK_SIZE; lx++) {
            for (let lz = 0; lz < CHUNK_SIZE; lz++) {
                const wx = worldX0 + lx;
                const wz = worldZ0 + lz;
                const columnKey = `${wx},${wz}`;
                const columnHeight = heights[columnKey];
                const columnBiome = columnBiomes.get(columnKey) || BIOME_SETTINGS.meadow;
                let soilLayers = (columnBiome && typeof columnBiome.soilLayers === 'number') ? columnBiome.soilLayers : DIRT_LAYERS;
                // Always place bedrock at y=0
                {
                    const m = new THREE.Matrix4();
                    m.makeTranslation(wx + 0.5, 0 + 0.5, wz + 0.5);
                    matrices.bedrock.push(m);
                    positionsByType.bedrock.push({ x: wx, y: 0, z: wz });
                    // store bedrock in voxelMap (unbreakable)
                    voxelMap.set(`${wx},0,${wz}`, { type: 'bedrock', chunk: chunkKeyString });
                }
                // Terrain generation loop.  Start at y=1 because y=0 is reserved
                // for bedrock.  Without this guard, a terrain block placed at
                // y=0 would overwrite the bedrock entry in voxelMap and
                // result in an unbreakable invisible block beneath the dirt.
                for (let y = 1; y <= columnHeight; y++) {
                    // Determine if block is exposed (visible) to avoid drawing hidden blocks
                    // We'll still record voxels for collision and picking even if hidden.  For
                    // simplicity, we keep the previous visibility test but still add the
                    // voxelMap entry.
                    const neighbourCoords = [[wx+1,wz],[wx-1,wz],[wx,wz+1],[wx,wz-1],[wx,wz]];
                    let exposed = false;
                    for (const [nx,nz] of neighbourCoords) {
                        const nh = heights[`${nx},${nz}`];
                        if (nh === undefined || nh < y+1) { exposed = true; break; }
                    }
                    // Skip blocks that lie within a cave entrance.  Entrance cells
                    // remove the top ENTRANCE_DEPTH layers of the column, creating
                    // a hole down into the world.  Continue to the next y if
                    // this position lies inside an entrance.
                    const cellKey = `${wx},${wz}`;
                    if (entranceCells.has(cellKey) && y > columnHeight - ENTRANCE_DEPTH) {
                        continue;
                    }
                    // Determine block type.  Surface blocks become grass (or sand below the
                    // water level), the next DIRT_LAYERS blocks become dirt, and
                    // everything below becomes stone.
                    let matKey;
                    let surfaceBlock = (columnHeight < waterLevel)
                        ? (columnBiome.underwaterSurface || columnBiome.surface || 'sand')
                        : (columnBiome.surface || 'grass');
                    let subsurfaceBlock = columnBiome.subsurface || 'dirt';
                    let deepBlock = columnBiome.deep || 'stone';
                    const belowWater = columnHeight < waterLevel - 1;
                    const coastal = !belowWater && columnHeight >= waterLevel - 2 && columnHeight <= waterLevel + 2;
                    const depthBelowSea = waterLevel - columnHeight;
                    if (belowWater) {
                        surfaceBlock = 'sand';
                        subsurfaceBlock = 'sand';
                        deepBlock = 'stone';
                        if (depthBelowSea > 8) {
                            soilLayers = Math.max(soilLayers, 6);
                        } else if (depthBelowSea > 4) {
                            soilLayers = Math.max(soilLayers, 5);
                        } else {
                            soilLayers = Math.max(soilLayers, 4);
                        }
                    } else if (coastal) {
                        surfaceBlock = 'sand';
                        subsurfaceBlock = 'sand';
                        soilLayers = Math.max(soilLayers, 3);
                    }
                    if (y === columnHeight) {
                        matKey = surfaceBlock;
                    } else if (soilLayers > 0 && y >= columnHeight - soilLayers) {
                        matKey = subsurfaceBlock;
                    } else {
                        matKey = deepBlock;
                        // Introduce ores in deeper stone layers.  Use a
                        // deterministic random seed based on world
                        // coordinates and depth so ores align across
                        // chunk boundaries.  Only generate ores below
                        // the dirt layers to avoid ores appearing on
                        // the surface.
                        if (matKey === 'stone' && y <= columnHeight - soilLayers) {
                            const oreSeed = (seed ^ (wx * 912373) ^ (y * 190713) ^ (wz * 827927)) >>> 0;
                            const oreRng  = mulberry32(oreSeed)();
                            if (columnBiome.glowstoneInStone && oreRng < columnBiome.glowstoneInStone) {
                                matKey = 'glowstone';
                            } else if (oreRng < 0.0007) {
                                matKey = 'diamond';
                            } else if (oreRng < 0.0015) {
                                matKey = 'ruby';
                            } else if (oreRng < 0.004) {
                                matKey = 'copper';
                            } else if (oreRng < 0.008) {
                                matKey = 'iron';
                            } else if (oreRng < 0.015) {
                                matKey = 'coal';
                            } else {
                                // At very deep depths occasionally spawn lava instead of stone.
                                if (y <= 6) {
                                    // Use a secondary RNG for lava chance
                                    const lavSeed = (oreSeed ^ 0x1234) >>> 0;
                                    const lavRand = mulberry32(lavSeed)();
                                if (lavRand < 0.02) {
                                        matKey = 'lava';
                                    }
                                }
                            }
                        }
                    }
                    // Carve caves out of stone below the dirt layers using layered noise.
                    let carved = false;
                    if (matKey === 'stone' && y <= columnHeight - DIRT_LAYERS) {
                        const baseVal = (caveNoisePrimary(wx, y * 0.72, wz, 4, 0.55, CAVE_BASE_FREQUENCY) + 1) / 2;
                        const detailVal = (caveNoiseDetail(wx, y * 1.05, wz, 3, 0.6, CAVE_DETAIL_FREQUENCY) + 1) / 2;
                        const cavernVal = (cavernNoise(wx, y * 0.55, wz, 2, 0.58, CAVERN_FREQUENCY) + 1) / 2;
                        const verticalRipple = (Math.sin(y * CAVE_VERTICAL_RIPPLE_FREQ) + 1) / 2;
                        const carveValue = baseVal * 0.6 + detailVal * 0.4;
                        let threshold = CAVE_THRESHOLD - (verticalRipple - 0.5) * CAVE_VERTICAL_RIPPLE_STRENGTH;
                        if (cavernVal > CAVE_CAVERN_THRESHOLD) {
                            threshold -= (cavernVal - CAVE_CAVERN_THRESHOLD) * CAVE_CAVERN_BOOST;
                        }
                        if (carveValue > threshold && y > CAVE_MIN_Y) {
                            carved = true;
                        }
                    }
                    if (carved) {
                        // Skip carved blocks completely
                        continue;
                    }
                    // Record voxel in voxelMap irrespective of visibility
                    voxelMap.set(`${wx},${y},${wz}`, { type: matKey, chunk: chunkKeyString });
                    // Determine whether to draw this block.  Previously we
                    // avoided drawing hidden blocks to improve performance, but
                    // this resulted in "invisible" solid blocks that the player
                    // could stand on but not see.  To fix that we now draw
                    // every terrain block except those carved out to form
                    // caves.  This eliminates the issue where invisible
                    // collisions remain after terrain generation.  If you wish
                    // to optimise further you could reintroduce the exposed
                    // check here, but ensure that hidden voxels are also
                    // considered non‚Äësolid.
                    let draw = true;
                    // Keep support for optional exposure checks; in case
                    // exposed is true we still draw, otherwise still true.
                    // draw remains true regardless, so all blocks are drawn.
                    if (!draw) continue;
                    const m = new THREE.Matrix4();
                    m.makeTranslation(wx + 0.5, y + 0.5, wz + 0.5);
                    matrices[matKey].push(m);
                    positionsByType[matKey].push({ x: wx, y, z: wz });
                }
                // Water generation loop
                if (columnHeight < waterLevel) {
                    for (let y = columnHeight + 1; y <= waterLevel; y++) {
                        const waterType = (columnBiome.freezeWater && y === waterLevel) ? 'ice' : 'water';
                        voxelMap.set(`${wx},${y},${wz}`, { type: waterType, chunk: chunkKeyString });
                        const m = new THREE.Matrix4();
                        m.makeTranslation(wx + 0.5, y + 0.5, wz + 0.5);
                        matrices[waterType].push(m);
                        positionsByType[waterType].push({ x: wx, y, z: wz });
                        if (waterType !== 'water') {
                            const colKey = `${wx},${wz}`;
                            if (heightMap[colKey] === undefined || y > heightMap[colKey]) {
                                heightMap[colKey] = y;
                            }
                        }
                    }
                }
                // Tree and flora generation tailored by biome.
                const treeType = columnBiome.treeType;
                const treeChance = columnBiome.treeChance || 0;
                if (treeType && columnHeight >= waterLevel) {
                    const rand = coordSeededRand(cx, cz, wx, wz)();
                    if (rand < treeChance) {
                        growTree(treeType, wx, columnHeight + 1, wz, columnBiome);
                    }
                }
                if (columnBiome.decorations) {
                    const decoRand = coordSeededRand(cx, cz, wx * 7, wz * 13)();
                    let threshold = 0;
                    if (columnBiome.decorations.glowstone) {
                        threshold += columnBiome.decorations.glowstone;
                        if (decoRand < threshold) {
                            queueBlock('glowstone', wx, columnHeight + 1, wz);
                        }
                    }
                    if (columnBiome.decorations.moss && decoRand >= threshold) {
                        threshold += columnBiome.decorations.moss;
                        if (decoRand < threshold && columnHeight >= waterLevel) {
                            queueBlock('moss', wx, columnHeight + 1, wz);
                        }
                    }
                }
                if (columnBiome.skyIslands) {
                    const skyStrength = columnBiome.samples ? columnBiome.samples.sky : sampleBiomeNoise(skyIslandNoise, wx, wz, BIOME_FREQUENCY * 0.5);
                    if (skyStrength > 0.82) {
                        let isPeak = true;
                        for (let nx = -1; nx <= 1 && isPeak; nx++) {
                            for (let nz = -1; nz <= 1; nz++) {
                                if (nx === 0 && nz === 0) continue;
                                const neighbour = getBiomeAt(wx + nx, wz + nz);
                                const neighbourSky = neighbour && neighbour.samples ? neighbour.samples.sky : sampleBiomeNoise(skyIslandNoise, wx + nx, wz + nz, BIOME_FREQUENCY * 0.5);
                                if (neighbourSky > skyStrength) {
                                    isPeak = false;
                                    break;
                                }
                            }
                        }
                        if (isPeak) {
                            spawnSkyIsland(wx, wz, columnHeight, skyStrength);
                        }
                    }
                }
            }
        }
        // Create instanced meshes for each block type
        const group = new THREE.Group();
        group.position.set(0,0,0);
        const instancedMeshes = [];
        const instancedByType = new Map();
        // For each type create instanced mesh and record mapping to voxelInstances
        for (const key of Object.keys(matrices)) {
            const mats = matrices[key];
            if (mats.length === 0) continue;
            const mat = blockMaterials[key];
            const inst = new THREE.InstancedMesh(cubeGeometry, mat, mats.length);
            inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            for (let i = 0; i < mats.length; i++) {
                inst.setMatrixAt(i, mats[i]);
            }
            inst.matrixAutoUpdate = false;
            inst.receiveShadow = true;
            inst.castShadow = (key !== 'water');
            group.add(inst);
            instancedMeshes.push(inst);
            instancedByType.set(key, inst);
            // Register instance indices in voxelInstances
            const positions = positionsByType[key];
            for (let i = 0; i < positions.length; i++) {
                const { x, y, z } = positions[i];
                const globalKey = `${x},${y},${z}`;
                voxelInstances.set(globalKey, { mesh: inst, index: i, chunk: chunkKeyString, type: key });
            }
        }
        const chunkData = { cx, cz, group, instancedMeshes, instancedByType, waterCells: new Set(), waterMesh: null };
        for (const cell of waterCells) {
            chunkData.waterCells.add(`${cell.x},${cell.y},${cell.z}`);
        }
        rebuildChunkWaterGeometry(chunkData);
        return chunkData;
    }
    // Dispose chunk
    function disposeChunk(chunk) {
        if (!chunk) return;
        scene.remove(chunk.group);
        for (const inst of chunk.instancedMeshes) {
            if (inst.material) inst.material.dispose();
        }
        if (chunk.waterMesh) {
            chunk.group.remove(chunk.waterMesh);
            if (chunk.waterMesh.geometry) chunk.waterMesh.geometry.dispose();
            chunk.waterMesh = null;
        }
        // Remove any voxel instance mappings belonging to this chunk and
        // corresponding voxelMap entries.  The chunkKey is derived from the
        // chunk's coordinates.  Dynamically placed blocks (chunk 'mod') are
        // unaffected here.
        const ck = `${chunk.cx},${chunk.cz}`;
        for (const [key, info] of Array.from(voxelInstances.entries())) {
            if (info.chunk === ck) {
                voxelInstances.delete(key);
                voxelMap.delete(key);
            }
        }
        for (const [key, entry] of Array.from(voxelMap.entries())) {
            if (entry.chunk === ck) {
                voxelMap.delete(key);
            }
        }
        if (chunk.waterCells) chunk.waterCells.clear();
        const neighbourOffsets = [[1,0], [-1,0], [0,1], [0,-1]];
        for (const [dx, dz] of neighbourOffsets) {
            const neighbour = chunkMap.get(`${chunk.cx + dx},${chunk.cz + dz}`);
            if (neighbour) rebuildChunkWaterGeometry(neighbour);
        }
    }
    function clearAllChunks() {
        for (const chunk of chunkMap.values()) disposeChunk(chunk);
        chunkMap.clear();
        // Remove all voxel entries associated with chunks
        voxelMap.clear();
        voxelInstances.clear();
        // Remove any dynamically placed blocks from the scene
        for (const mesh of modifiedMeshes) {
            scene.remove(mesh);
        }
        modifiedMeshes.length = 0;
        biomeCache.clear();
    }
    function cameraToChunkCoord(pos) {
        const cx = Math.floor(pos.x / CHUNK_SIZE);
        const cz = Math.floor(pos.z / CHUNK_SIZE);
        return { cx, cz };
    }
    function updateVisibleChunks(force = false) {
        const { cx: camCx, cz: camCz } = cameraToChunkCoord(camera.position);
        const needed = new Set();
        for (let dz = -VIEW_DISTANCE_CHUNKS; dz <= VIEW_DISTANCE_CHUNKS; dz++) {
            for (let dx = -VIEW_DISTANCE_CHUNKS; dx <= VIEW_DISTANCE_CHUNKS; dx++) {
                const cx = camCx + dx;
                const cz = camCz + dz;
                const key = `${cx},${cz}`;
                needed.add(key);
                if (!chunkMap.has(key) || force) {
                    const chunk = generateChunk(cx, cz);
                    chunkMap.set(key, chunk);
                    scene.add(chunk.group);
                    refreshWaterForChunkAndNeighbours(chunk);
                }
            }
        }
        for (const key of Array.from(chunkMap.keys())) {
            if (!needed.has(key)) {
                const chunk = chunkMap.get(key);
                disposeChunk(chunk);
                chunkMap.delete(key);
            }
        }
    }

    // --- Player state ---
    const player = {
        position: new THREE.Vector3(0, 10, 80),
        velocityY: 0,
        yaw: 0,
        pitch: 0,
        moveForward: false,
        moveBackward: false,
        moveLeft: false,
        moveRight: false,
        jumpHeld: false,
        canJump: false,
        isSprinting: false,
        isCrouching: false,
        crouchOffset: 0,
        inWater: false,
        headSubmerged: false,
    };
    let pointerLocked = false;

    // --- Init three.js and world ---
    function init() {
        scene = new THREE.Scene();
        // Set an initial sky colour and fog ‚Äì these will be updated in the
        // day/night cycle.  The colour chosen here does not matter much
        // because updateSky() will override it on the first frame.
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 150, 400);
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.copy(player.position);
        // Attach the camera to the scene so that child objects (like the first-person
        // hand) render correctly. Without this, any meshes parented to the camera are
        // not traversed during rendering and remain invisible.
        scene.add(camera);

        // Initialize lastYPosition for fall damage calculations with the
        // player's starting height.
        lastYPosition = player.position.y;
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.15;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        // Initialise the sky elements including clouds, sun, moon, stars and
        // dynamic lights.  initSky() will add its own lights; the old
        // ambient and directional lights are no longer created here.
        initSky();
        spawnAmbientCreatures();

        // Audio listener and sound initialization
        audioListener = new THREE.AudioListener();
        camera.add(audioListener);
        // Loader for step sounds
        const audioLoader = new THREE.AudioLoader();
        if (audioLoader.setCrossOrigin) audioLoader.setCrossOrigin('anonymous');
        STEP_SOUND_URLS.forEach((url) => {
            const sound = new THREE.Audio(audioListener);
            audioLoader.load(url, (buffer) => {
                sound.setBuffer(buffer);
                sound.setVolume(0.5);
            }, undefined, (err) => {
                console.warn('Failed to load sound', url, err);
            });
            stepSounds.push(sound);
        });
        // Load dig/break sounds into separate arrays for each category.  A
        // single AudioLoader instance can be reused for all sounds.  We set
        // volume slightly lower to avoid overpowering the ambient music.
        const digCategories = Object.keys(DIG_SOUND_URLS);
        digCategories.forEach((cat) => {
            digSounds[cat] = [];
            DIG_SOUND_URLS[cat].forEach((url) => {
                const s = new THREE.Audio(audioListener);
                audioLoader.load(url, (buffer) => {
                    s.setBuffer(buffer);
                    s.setVolume(0.5);
                }, undefined, (err) => {
                    console.warn('Failed to load dig sound', url, err);
                });
                digSounds[cat].push(s);
            });
        });

        // Load damage and death sounds.  Damage sounds play when the
        // player takes damage (e.g. from falling or lava).  The death
        // sound plays when health reaches zero.  These are loaded as
        // HTMLAudioElements to allow easy volume control and playback.
        const damageUrls = [
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/damage/hit1.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/damage/hit2.ogg',
            'https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/damage/hit3.ogg'
        ];
        damageUrls.forEach((url) => {
            const a = new Audio(url);
            a.volume = 0.6 * masterVolume * sfxVolume;
            damageSounds.push(a);
        });
        // Use hit3 as the death sound
        deathSound = new Audio('https://assets.mcasset.cloud/1.21.5/assets/minecraft/sounds/damage/hit3.ogg');
        deathSound.volume = 0.7 * masterVolume * sfxVolume;
        // Loader and audio object for background music
        music = new THREE.Audio(audioListener);
        musicLoader = new THREE.AudioLoader();
        if (musicLoader.setCrossOrigin) musicLoader.setCrossOrigin('anonymous');
        // Create a highlight mesh that outlines the targeted block.  It is
        // invisible by default and will be positioned each frame when a block
        // is under the crosshair.  The slight size increase (1.02) makes
        // the outline visible around the block faces.
        {
            // Use EdgesGeometry to draw only the outer edges of the box.  This
            // avoids the diagonal lines across the faces that appear when
            // rendering a box in wireframe mode.  The slight size
            // enlargement ensures the outline is visible around the
            // targeted block.
            const boxGeo = new THREE.BoxGeometry(1.02, 1.02, 1.02);
            const edgesGeo = new THREE.EdgesGeometry(boxGeo);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.9 });
            highlightMesh = new THREE.LineSegments(edgesGeo, lineMat);
            highlightMesh.visible = false;
            scene.add(highlightMesh);
        }

        // Create a mesh to display block break cracks.  Minecraft shows
        // progressive cracking as a block is being broken.  We predefine a
        // slightly larger cube to avoid z‚Äëfighting with the block surface.
        // The material will be swapped each frame according to the break
        // progress.  Initially invisible.
        {
            // Create a cracks mesh using a simple box geometry.  The box
            // is slightly larger than a block (1.02 units) to prevent
            // z‚Äëfighting with the underlying voxel.  Unlike the previous
            // implementation, no extrusion or random offsets are applied.
            // This gives a flat overlay similar to Minecraft's crack
            // texture, which appears as a 2D pattern on the block faces.
            const cGeo = new THREE.BoxGeometry(1.02, 1.02, 1.02);
            cracksMesh = new THREE.Mesh(cGeo, destroyMaterials[0]);
            cracksMesh.visible = false;
            scene.add(cracksMesh);
        }
        // Create the block mesh that shows the currently selected block.  It
        // uses a slightly reduced scale and is positioned so the held item sits
        // toward the lower-right corner of the screen, similar to Minecraft's
        // hand placement.
        const initialType = selectableTypes[selectedIndex];
        const initialMaterial = (initialType && blockMaterials[initialType]) ? getHandMaterialForType(initialType) : emptyHandMaterial;
        const initialCount = initialType ? (inventory[initialType] || 0) : 0;
        handBlock = new THREE.Mesh(cubeGeometry.clone(), initialMaterial);
        handBlock.visible = !!initialType && initialCount > 0;
        handBlock.scale.set(0.72, 0.72, 0.72);
        handBlock.position.set(0.08, -0.08, -0.16);
        handBlock.rotation.set(-Math.PI / 7, Math.PI / 5.5, Math.PI / 16);
        handBlock.renderOrder = 32;
        // Group the held item meshes together for animation.  When the player
        // has nothing selected the entire group is hidden so no ghost arm is
        // rendered.
        handGroup = new THREE.Group();
        handGroup.add(handBlock);
        const stickMesh = createStickMesh();
        stickMesh.position.set(0.16, -0.18, -0.26);
        stickMesh.visible = false;
        handGroup.add(stickMesh);
        handItemMeshes.stick = stickMesh;
        const toolTransforms = {
            axe: { position: [0.24, -0.2, -0.34], rotation: [-1.18, 0.92, 0.32], scale: 1.08 },
            pickaxe: { position: [0.18, -0.16, -0.38], rotation: [-1.12, 0.76, -0.28], scale: 1.04 },
            sword: { position: [0.2, -0.22, -0.32], rotation: [-1.25, 0.88, 0.1], scale: 1.12 },
            shovel: { position: [0.22, -0.18, -0.36], rotation: [-1.2, 0.82, -0.12], scale: 1.08 }
        };
        TOOL_VARIANTS.forEach((variant) => {
            TOOL_KINDS.forEach((kind) => {
                const factory = TOOL_FACTORIES[kind];
                if (!factory) return;
                const mesh = factory({ variant });
                const transform = toolTransforms[kind];
                if (transform) {
                    mesh.position.set(...transform.position);
                    mesh.rotation.set(...transform.rotation);
                    mesh.scale.setScalar(transform.scale);
                }
                mesh.visible = false;
                handGroup.add(mesh);
                handItemMeshes[`${variant}_${kind}`] = mesh;
            });
        });
        // Position the held item group relative to the camera so it sits clearly
        // in view on the right-hand side.  The group is brought a little
        // closer to the lens so items appear substantial without clipping into
        // the camera near plane.
        handGroup.position.set(0.66, -0.56, -0.78);
        handGroup.rotation.set(-0.16, 0.36, 0.14);
        handGroup.visible = !!(initialType && initialCount > 0);
        // Capture the base position and rotation for animations
        handBasePosition = handGroup.position.clone();
        handBaseRotation = handGroup.rotation.clone();
        // Attach the group to the camera
        camera.add(handGroup);
        updateHandBlockMaterial();
        // handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        // The legacy UI buttons have been removed.  World regeneration and
        // repositioning can still be triggered via the exposed _voxelWorld
        // helpers in the console if needed, but no clickable UI is present.
        // Initialize the hotbar UI once the DOM is ready.  The bar is hidden
        // until pointer lock is acquired.
        initHotbar();

        // Initialise the inventory overlay and its UI elements.  This
        // creates slots for each block type and sets up search and
        // click handlers.  The inventory is hidden by default until
        // toggled with the E key.
        initInventoryUI();

        // Initialize hearts UI and display full health at the start
        updateHearts();

        // initialize noise and chunks
        perlinNoise = createPerlin(seed);
        heatNoise = createPerlin(seed ^ 0x51633);
        moistureNoise = createPerlin(seed ^ 0x9f4c3);
        mysticNoise = createPerlin(seed ^ 0x1f2a7);
        skyIslandNoise = createPerlin(seed ^ 0x7ab9d);
        caveNoisePrimary = createPerlin3D(seed ^ 0x4ad34);
        caveNoiseDetail = createPerlin3D(seed ^ 0x7c9f1);
        cavernNoise = createPerlin3D(seed ^ 0x1bd45);
        biomeCache.clear();
        updateVisibleChunks(true);
        // Apply volume settings now that audio objects have been created.  This
        // call ensures that in‚Äëgame music and sound effects respect the
        // saved master/music/SFX volumes from localStorage.
        if (typeof applyVolumeSettings === 'function') applyVolumeSettings();
        // pointer lock handling
        renderer.domElement.addEventListener('click', () => {
            if (!pointerLocked) {
                renderer.domElement.requestPointerLock();
            }
        });
        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === renderer.domElement;
            // show/hide crosshair
            document.getElementById('crosshair').style.display = pointerLocked ? 'block' : 'none';
            // slide the hotbar into view when pointer is locked
            const bar = document.getElementById('hotbar');
            if (bar) {
                if (pointerLocked || inventoryOpen) bar.classList.add('visible');
                else bar.classList.remove('visible');
                if (inventoryOpen) bar.classList.add('interactive');
                else bar.classList.remove('interactive');
            }
            if (!pointerLocked) {
                leftMouseDown = false;
                rightMouseDown = false;
                placeHoldCooldown = 0;
                cancelBreaking();
                player.jumpHeld = false;
            }
            // Start background music when the user first locks the pointer
            if (pointerLocked && !musicStarted) {
                musicStarted = true;
                playRandomMusic();
            }
        });
        document.addEventListener('mousemove', (event) => {
            if (!pointerLocked) return;
            const sensitivity = 0.002;
            player.yaw   -= event.movementX * sensitivity;
            player.pitch -= event.movementY * sensitivity;
            // clamp pitch to avoid flipping over (approx +/- 90 deg)
            const maxPitch = Math.PI / 2 - 0.1;
            player.pitch = Math.max(-maxPitch, Math.min(maxPitch, player.pitch));
        });
        // key handling
        document.addEventListener('keydown', (e) => {
            const targetTag = e.target && e.target.tagName ? e.target.tagName.toUpperCase() : '';
            const typing = targetTag === 'INPUT' || targetTag === 'TEXTAREA';
            if (typing && e.code !== 'Escape') return;
            switch (e.code) {
                case 'KeyW':
                case 'ArrowUp':
                    if (inventoryOpen) {
                        e.preventDefault();
                        break;
                    }
                    player.moveForward = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    if (inventoryOpen) {
                        e.preventDefault();
                        break;
                    }
                    player.moveBackward = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    if (inventoryOpen) {
                        e.preventDefault();
                        break;
                    }
                    player.moveLeft = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    if (inventoryOpen) {
                        e.preventDefault();
                        break;
                    }
                    player.moveRight = true;
                    break;
                case 'Space':
                    if (inventoryOpen) {
                        e.preventDefault();
                        break;
                    }
                    player.jumpHeld = true;
                    if (player.canJump) {
                        // Initiate jump and trigger a step sound on jump
                        player.velocityY = JUMP_VELOCITY;
                        player.canJump = false;
                        playRandomStepSound();
                    }
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    if (inventoryOpen) {
                        e.preventDefault();
                        break;
                    }
                    player.isSprinting = true;
                    break;
                case 'KeyC':
                    if (inventoryOpen) {
                        e.preventDefault();
                        break;
                    }
                    if (!e.repeat) {
                        player.isCrouching = !player.isCrouching;
                    }
                    break;
                case 'KeyE': {
                    // Open or close the inventory overlay.  Prevent default
                    // behaviour to avoid triggering browser search or other
                    // actions.  Toggling inventory unlocks pointer and
                    // pauses/resumes the game accordingly.  Do not toggle
                    // when pointer lock is not yet acquired (e.g. menu).
                    e.preventDefault();
                    toggleInventory();
                    break;
                }
                case 'KeyQ':
                    if (pointerLocked && !inventoryOpen) {
                        e.preventDefault();
                        dropSelectedBlock();
                    }
                    break;
                // Number keys 1‚Äì9 change the selected block type for placement
                case 'Digit1':
                case 'Digit2':
                case 'Digit3':
                case 'Digit4':
                case 'Digit5':
                case 'Digit6':
                case 'Digit7':
                case 'Digit8':
                case 'Digit9': {
                    // Convert the last character of the code to an index (0‚Äëbased)
                    const idx = parseInt(e.code.substr(5)) - 1;
                    if (idx >= 0 && idx < selectableTypes.length) {
                        selectedIndex = idx;
                        updateHandBlockMaterial();
                    }
                    break;
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            const targetTag = e.target && e.target.tagName ? e.target.tagName.toUpperCase() : '';
            const typing = targetTag === 'INPUT' || targetTag === 'TEXTAREA';
            if (typing && e.code !== 'Escape') return;
            switch (e.code) {
                case 'KeyW':
                case 'ArrowUp':
                    player.moveForward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    player.moveBackward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    player.moveLeft = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    player.moveRight = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    player.isSprinting = false;
                    break;
                case 'Space':
                    player.jumpHeld = false;
                    break;
            }
        });

        // Mouse input for breaking and placing blocks.  Listen on the
        // renderer's DOM element to avoid receiving events when the pointer
        // is not locked.  Right click placement uses contextmenu
        // prevention.
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (!pointerLocked) return;
            if (e.button === 0) {
                leftMouseDown = true;
                startBreaking();
            } else if (e.button === 2) {
                e.preventDefault();
                rightMouseDown = true;
                if (tryPlaceBlock()) {
                    placeHoldCooldown = PLACE_REPEAT_INTERVAL;
                } else {
                    placeHoldCooldown = PLACE_REPEAT_INTERVAL * 0.5;
                }
            }
        });
        renderer.domElement.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                leftMouseDown = false;
                cancelBreaking();
            } else if (e.button === 2) {
                rightMouseDown = false;
                placeHoldCooldown = 0;
            }
        });
        renderer.domElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        // update visible chunks periodically based on player's chunk
        let lastCamChunk = cameraToChunkCoord(player.position);
        setInterval(() => {
            const curr = cameraToChunkCoord(player.position);
            if (curr.cx !== lastCamChunk.cx || curr.cz !== lastCamChunk.cz) {
                lastCamChunk = curr;
                updateVisibleChunks();
            }
        }, 500);
    }
    // Helper: get the highest solid block Y at world (x,z).  Returns the
    // integer y coordinate of the highest block at the given column.  If no
    // blocks have been generated at that column, return -Infinity.  This
    // function is used for collision detection and to determine the ground
    // surface; the player's centre should be positioned at (highest + 1 +
    // PLAYER_HEIGHT/2) to stand on top of the block.
    function getHighestBlockY(x, z) {
        const ix = Math.floor(x);
        const iz = Math.floor(z);
        const key = `${ix},${iz}`;
        return (heightMap[key] !== undefined) ? heightMap[key] : -Infinity;
    }
    // Helper: test if there is a solid voxel at integer (x,y,z)
    function isSolid(x, y, z) {
        const entry = voxelMap.get(`${x},${y},${z}`);
        if (!entry) return false;
        const t = entry.type;
        // Water and lava remain non-solid; everything else (including leaves) is solid.
        return (t !== 'water' && t !== 'lava');
    }

    function getVoxelType(x, y, z) {
        if (y < 0 || y >= CHUNK_HEIGHT) return null;
        const entry = voxelMap.get(`${x},${y},${z}`);
        return entry ? entry.type : null;
    }

    function isWaterVoxel(x, y, z) {
        return getVoxelType(x, y, z) === 'water';
    }

    function sampleWaterState(px, py, pz) {
        const offsets = [
            [0, 0],
            [0.3, 0.3],
            [-0.3, 0.3],
            [0.3, -0.3],
            [-0.3, -0.3]
        ];
        let inWater = false;
        let headSubmerged = false;
        let surfaceY = null;
        const head = py + PLAYER_HEIGHT / 2 - 0.05;
        const chest = py;
        const feet = py - PLAYER_HEIGHT / 2 + 0.05;
        for (const [ox, oz] of offsets) {
            const x = Math.floor(px + ox);
            const z = Math.floor(pz + oz);
            const headCell = Math.floor(head);
            const chestCell = Math.floor(chest);
            const feetCell = Math.floor(feet);
            const headWater = isWaterVoxel(x, headCell, z);
            const chestWater = isWaterVoxel(x, chestCell, z);
            const feetWater = isWaterVoxel(x, feetCell, z);
            if (!(headWater || chestWater || feetWater)) continue;
            inWater = true;
            if (headWater) headSubmerged = true;
            let y = headWater ? headCell : (chestWater ? chestCell : feetCell);
            while (isWaterVoxel(x, y + 1, z)) y++;
            const candidateSurface = y + 1;
            surfaceY = (surfaceY === null) ? candidateSurface : Math.max(surfaceY, candidateSurface);
        }
        return { inWater, headSubmerged, surfaceY };
    }

    // Find the highest solid block at the given column that is at or below maxY.
    // Returns the integer y coordinate of the supporting block, or -Infinity
    // if no solid block exists at or below that height.
    function findSupportingBlockY(x, maxY, z) {
        const clamped = Math.min(maxY, CHUNK_HEIGHT - 1);
        for (let yy = clamped; yy >= 0; yy--) {
            if (isSolid(x, yy, z)) {
                return yy;
            }
        }
        return -Infinity;
    }

    function worldToChunkKey(x, z) {
        const cx = Math.floor(x / CHUNK_SIZE);
        const cz = Math.floor(z / CHUNK_SIZE);
        return `${cx},${cz}`;
    }

    function buildWaterGeometryFromCells(cells) {
        if (!cells || cells.length === 0) return null;
        const positions = [];
        const normals = [];
        const uvs = [];
        const uvBase = [[0, 0], [1, 0], [1, 1], [0, 1]];
        const pushFace = (verts, normal, order) => {
            const [nx, ny, nz] = normal;
            for (let i = 0; i < order.length; i++) {
                const idx = order[i];
                const v = verts[idx];
                const uv = uvBase[idx];
                positions.push(v[0], v[1], v[2]);
                normals.push(nx, ny, nz);
                uvs.push(uv[0], uv[1]);
            }
        };
        for (const cell of cells) {
            const { x, y, z } = cell;
            const topWater = isWaterVoxel(x, y + 1, z);
            const bottomWater = isWaterVoxel(x, y - 1, z);
            const northWater = isWaterVoxel(x, y, z - 1);
            const southWater = isWaterVoxel(x, y, z + 1);
            const eastWater = isWaterVoxel(x + 1, y, z);
            const westWater = isWaterVoxel(x - 1, y, z);
            if (!topWater) {
                pushFace([
                    [x, y + 1, z],
                    [x + 1, y + 1, z],
                    [x + 1, y + 1, z + 1],
                    [x, y + 1, z + 1]
                ], [0, 1, 0], [0, 3, 2, 0, 2, 1]);
            }
            if (!bottomWater) {
                pushFace([
                    [x, y, z + 1],
                    [x + 1, y, z + 1],
                    [x + 1, y, z],
                    [x, y, z]
                ], [0, -1, 0], [0, 2, 1, 0, 3, 2]);
            }
            if (!eastWater) {
                pushFace([
                    [x + 1, y, z],
                    [x + 1, y, z + 1],
                    [x + 1, y + 1, z + 1],
                    [x + 1, y + 1, z]
                ], [1, 0, 0], [0, 2, 1, 0, 3, 2]);
            }
            if (!westWater) {
                pushFace([
                    [x, y, z + 1],
                    [x, y, z],
                    [x, y + 1, z],
                    [x, y + 1, z + 1]
                ], [-1, 0, 0], [0, 2, 1, 0, 3, 2]);
            }
            if (!southWater) {
                pushFace([
                    [x + 1, y, z + 1],
                    [x, y, z + 1],
                    [x, y + 1, z + 1],
                    [x + 1, y + 1, z + 1]
                ], [0, 0, 1], [0, 2, 1, 0, 3, 2]);
            }
            if (!northWater) {
                pushFace([
                    [x, y, z],
                    [x + 1, y, z],
                    [x + 1, y + 1, z],
                    [x, y + 1, z]
                ], [0, 0, -1], [0, 2, 1, 0, 3, 2]);
            }
        }
        if (positions.length === 0) return null;
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        geometry.computeBoundingBox();
        geometry.computeBoundingSphere();
        return geometry;
    }

    function rebuildChunkWaterGeometry(chunk) {
        if (!chunk) return;
        if (chunk.waterMesh) {
            chunk.group.remove(chunk.waterMesh);
            if (chunk.waterMesh.geometry) chunk.waterMesh.geometry.dispose();
            chunk.waterMesh = null;
        }
        if (!chunk.waterCells || chunk.waterCells.size === 0) return;
        const cells = [];
        chunk.waterCells.forEach((key) => {
            const parts = key.split(',').map(Number);
            cells.push({ x: parts[0], y: parts[1], z: parts[2] });
        });
        const geometry = buildWaterGeometryFromCells(cells);
        if (!geometry) return;
        const mesh = new THREE.Mesh(geometry, blockMaterials.water);
        mesh.castShadow = false;
        mesh.receiveShadow = true;
        mesh.renderOrder = 2;
        chunk.group.add(mesh);
        chunk.waterMesh = mesh;
    }

    function refreshWaterForChunkAndNeighbours(chunk) {
        if (!chunk) return;
        const visited = new Set();
        const stack = [chunk];
        const offsets = [[1,0], [-1,0], [0,1], [0,-1]];
        while (stack.length > 0) {
            const current = stack.pop();
            if (!current || visited.has(current)) continue;
            visited.add(current);
            rebuildChunkWaterGeometry(current);
            for (const [dx, dz] of offsets) {
                const neighbour = chunkMap.get(`${current.cx + dx},${current.cz + dz}`);
                if (neighbour && !visited.has(neighbour)) {
                    stack.push(neighbour);
                }
            }
        }
    }

    function recomputeColumnHeight(x, z) {
        const colKey = `${x},${z}`;
        let newH = -Infinity;
        for (let yy = CHUNK_HEIGHT - 1; yy >= 0; yy--) {
            const entry = voxelMap.get(`${x},${yy},${z}`);
            if (entry && entry.type !== 'water' && entry.type !== 'leaves' && entry.type !== 'lava') {
                newH = yy;
                break;
            }
        }
        if (newH === -Infinity) delete heightMap[colKey];
        else heightMap[colKey] = newH;
    }

    // Cast a ray from the camera forward into the world to find the first
    // voxel that intersects the ray.  Returns an object with the voxel
    // coordinates { x, y, z }, the type of voxel, and the face normal of
    // the intersection.  If no block is hit within maxDist the function
    // returns null.  This uses a 3D DDA algorithm for efficiency.
    function pickBlock(maxDist = 6) {
        // Starting position and direction from the camera
        const origin = camera.position.clone();
        const dir = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation).normalize();
        // Initialize voxel coordinates
        let x = Math.floor(origin.x);
        let y = Math.floor(origin.y);
        let z = Math.floor(origin.z);
        // Determine the step direction and initial tMax and tDelta values
        const stepX = (dir.x > 0) ? 1 : (dir.x < 0 ? -1 : 0);
        const stepY = (dir.y > 0) ? 1 : (dir.y < 0 ? -1 : 0);
        const stepZ = (dir.z > 0) ? 1 : (dir.z < 0 ? -1 : 0);
        const tDeltaX = (dir.x !== 0) ? Math.abs(1 / dir.x) : Infinity;
        const tDeltaY = (dir.y !== 0) ? Math.abs(1 / dir.y) : Infinity;
        const tDeltaZ = (dir.z !== 0) ? Math.abs(1 / dir.z) : Infinity;
        // Compute initial distances to the first voxel boundary
        let tMaxX, tMaxY, tMaxZ;
        if (dir.x > 0) {
            tMaxX = ((x + 1) - origin.x) / dir.x;
        } else if (dir.x < 0) {
            tMaxX = (origin.x - x) / -dir.x;
        } else {
            tMaxX = Infinity;
        }
        if (dir.y > 0) {
            tMaxY = ((y + 1) - origin.y) / dir.y;
        } else if (dir.y < 0) {
            tMaxY = (origin.y - y) / -dir.y;
        } else {
            tMaxY = Infinity;
        }
        if (dir.z > 0) {
            tMaxZ = ((z + 1) - origin.z) / dir.z;
        } else if (dir.z < 0) {
            tMaxZ = (origin.z - z) / -dir.z;
        } else {
            tMaxZ = Infinity;
        }
        let dist = 0;
        let lastAxis = null;
        while (dist <= maxDist) {
            // Check current voxel
            const key = `${x},${y},${z}`;
            const entry = voxelMap.get(key);
            // Only consider solid blocks (skip water and leaves).  Hidden
            // blocks remain pickable so that the player can break through
            // dirt and stone layers even when they are not yet exposed.
            if (entry && entry.type !== 'water' && entry.type !== 'lava') {
                // Determine face normal based on last stepped axis
                let normal;
                if (lastAxis === 'x') normal = new THREE.Vector3(-stepX, 0, 0);
                else if (lastAxis === 'y') normal = new THREE.Vector3(0, -stepY, 0);
                else if (lastAxis === 'z') normal = new THREE.Vector3(0, 0, -stepZ);
                else normal = new THREE.Vector3(0,0,0);
                return { x, y, z, type: entry.type, normal };
            }
            // Step to next voxel along the ray
            if (tMaxX < tMaxY) {
                if (tMaxX < tMaxZ) {
                    x += stepX;
                    dist = tMaxX;
                    tMaxX += tDeltaX;
                    lastAxis = 'x';
                } else {
                    z += stepZ;
                    dist = tMaxZ;
                    tMaxZ += tDeltaZ;
                    lastAxis = 'z';
                }
            } else {
                if (tMaxY < tMaxZ) {
                    y += stepY;
                    dist = tMaxY;
                    tMaxY += tDeltaY;
                    lastAxis = 'y';
                } else {
                    z += stepZ;
                    dist = tMaxZ;
                    tMaxZ += tDeltaZ;
                    lastAxis = 'z';
                }
            }
        }
        return null;
    }
    // Update player movement & physics
    let prevTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = (time - prevTime) / 1000;
        prevTime = time;
        // If the game is paused, render the scene without updating the world.
        if (isPaused) {
            renderer.render(scene, camera);
            return;
        }
        // only update if pointer is locked (for orientation) but always move
        // Update camera orientation from player yaw/pitch
        camera.rotation.order = 'YXZ';
        camera.rotation.y = player.yaw;
        camera.rotation.x = player.pitch;

        // Determine the biome under the player for sky/lighting adjustments.
        currentBiomeInfo = getBiomeAt(player.position.x, player.position.z);
        // Update day/night cycle and cloud movement.  These functions
        // adjust the sky colours, sun and moon positions, star opacity,
        // lighting intensities and reposition clouds relative to the
        // camera.  They rely on delta time and the current camera
        // position.
        updateSky(delta);
        updateClouds(delta);
        updateAmbientCreatures(delta);
        // Determine movement direction on the XZ plane
        const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), player.yaw);
        const right  = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), player.yaw);
        let moveDir = new THREE.Vector3();
        if (player.moveForward) moveDir.add(forward);
        if (player.moveBackward) moveDir.add(forward.clone().multiplyScalar(-1));
        if (player.moveRight)   moveDir.add(right);
        if (player.moveLeft)    moveDir.add(right.clone().multiplyScalar(-1));
        const moving = (moveDir.lengthSq() > 0);
        if (moving) moveDir.normalize();
        let waterState = sampleWaterState(player.position.x, player.position.y, player.position.z);
        let waterSurfaceY = waterState.surfaceY;
        player.inWater = waterState.inWater;
        player.headSubmerged = waterState.headSubmerged;
        const crouchTarget = player.isCrouching ? 0.5 : 0;
        const crouchLerp = 1 - Math.exp(-delta * 12);
        player.crouchOffset = THREE.MathUtils.lerp(player.crouchOffset, crouchTarget, Math.min(1, crouchLerp));
        const baseSpeed = waterState.inWater ? SWIM_SPEED : MOVE_SPEED;
        const speedMult = player.isSprinting ? (waterState.inWater ? 1.25 : 1.6) : 1.0;
        const newX = player.position.x + moveDir.x * baseSpeed * speedMult * delta;
        const newZ = player.position.z + moveDir.z * baseSpeed * speedMult * delta;
        // Determine highest block columns for step check
        const curCol = getHighestBlockY(player.position.x, player.position.z);
        const newCol = getHighestBlockY(newX, newZ);
        let allowMove = true;
        // Disallow stepping up too high
        if (newCol - curCol > STEP_MAX) {
            allowMove = false;
        }
        if (allowMove && player.isCrouching && !waterState.inWater && moving) {
            const feetHeight = player.position.y - PLAYER_HEIGHT / 2 - 0.05;
            const signX = Math.sign(moveDir.x);
            const signZ = Math.sign(moveDir.z);
            const sampleOffsets = [
                [0, 0],
                [signX * 0.3, 0],
                [0, signZ * 0.3],
                [signX * 0.3, signZ * 0.3]
            ];
            let supported = true;
            for (const [ox, oz] of sampleOffsets) {
                const sx = Math.floor(newX + ox);
                const sz = Math.floor(newZ + oz);
                const supportY = findSupportingBlockY(sx, Math.floor(feetHeight), sz);
                if (!Number.isFinite(supportY) || feetHeight - (supportY + 1) > 0.25) {
                    supported = false;
                    break;
                }
            }
            if (!supported) allowMove = false;
        }
        // Horizontal collision detection with solid voxels (trees etc.)
        let blocked = false;
        const floorCurX = Math.floor(player.position.x);
        const floorCurZ = Math.floor(player.position.z);
        const floorNewX = Math.floor(newX);
        const floorNewZ = Math.floor(newZ);
        if ((floorNewX !== floorCurX) || (floorNewZ !== floorCurZ)) {
            // Vertical range excluding the ground block
            const yStart = Math.floor((player.position.y - PLAYER_HEIGHT/2) + 0.001) + 1;
            const yEnd   = Math.floor((player.position.y + PLAYER_HEIGHT/2) - 0.001);
            for (let y = yStart; y <= yEnd; y++) {
                if (isSolid(floorNewX, y, floorNewZ)) {
                    blocked = true;
                    break;
                }
            }
        }
        if (!blocked && allowMove) {
            player.position.x = newX;
            player.position.z = newZ;
        }
        waterState = sampleWaterState(player.position.x, player.position.y, player.position.z);
        waterSurfaceY = waterState.surfaceY;
        player.inWater = waterState.inWater;
        player.headSubmerged = waterState.headSubmerged;
        let newY = player.position.y;
        if (waterState.inWater) {
            const ascendHeld = player.jumpHeld;
            const descendHeld = player.isCrouching && !ascendHeld;
            const bobVelocity = (!waterState.headSubmerged && waterSurfaceY !== null)
                ? Math.sin(swimBobTime * UNDERWATER_BOB_SPEED * Math.PI * 2) * (SWIM_ASCEND_SPEED * 0.3)
                : 0;
            let targetVel;
            if (ascendHeld) targetVel = SWIM_ASCEND_SPEED;
            else if (descendHeld) targetVel = -SWIM_ASCEND_SPEED;
            else if (!waterState.headSubmerged && waterSurfaceY !== null) targetVel = bobVelocity;
            else targetVel = -SWIM_SINK_SPEED;
            const lerpFactor = 1 - Math.exp(-delta * WATER_DRAG);
            player.velocityY = THREE.MathUtils.lerp(player.velocityY, targetVel, lerpFactor);
            player.velocityY = THREE.MathUtils.clamp(player.velocityY, -SWIM_ASCEND_SPEED, SWIM_ASCEND_SPEED);
            newY += player.velocityY * delta;
        } else {
            player.velocityY -= GRAVITY * delta;
            newY += player.velocityY * delta;
        }
        // Determine ground surface (centre position to stand on top of highest block)
        const highestBelow = getHighestBlockY(player.position.x, player.position.z);
        const groundHeight = (highestBelow + 1) + PLAYER_HEIGHT/2;
        // Handle ground collision
        if (newY <= groundHeight) {
            newY = groundHeight;
            if (player.velocityY < 0) player.velocityY = 0;
            if (!waterState.inWater) player.canJump = true;
        } else if (!waterState.inWater) {
            player.canJump = false;
        }
        // Handle collision when head hits a solid block above
        const headY = newY + PLAYER_HEIGHT/2;
        const headCellY = Math.floor(headY);
        const cellX = Math.floor(player.position.x);
        const cellZ = Math.floor(player.position.z);
        if (isSolid(cellX, headCellY, cellZ)) {
            // Player hit the bottom of a block ‚Äì clamp position just below it
            newY = headCellY - PLAYER_HEIGHT/2 - 0.001;
            // Invert upward velocity
            if (player.velocityY > 0) player.velocityY = 0;
        }
        player.position.y = newY;
        waterState = sampleWaterState(player.position.x, player.position.y, player.position.z);
        waterSurfaceY = waterState.surfaceY;
        player.inWater = waterState.inWater;
        player.headSubmerged = waterState.headSubmerged;
        if (player.inWater) {
            fallDistance = 0;
            player.canJump = false;
        }
        if (player.inWater && !player.headSubmerged && waterSurfaceY !== null) {
            swimBobTime += delta;
            const targetOffset = Math.sin(swimBobTime * UNDERWATER_BOB_SPEED * Math.PI * 2) * UNDERWATER_BOB_AMPLITUDE;
            swimBobOffset = THREE.MathUtils.lerp(swimBobOffset, targetOffset, Math.min(1, delta * 6));
        } else {
            swimBobTime = 0;
            swimBobOffset = THREE.MathUtils.lerp(swimBobOffset, 0, Math.min(1, delta * 6));
        }
        updateUnderwaterAudioState(player.headSubmerged);
        // Determine whether player is currently on the ground
        const onGround = (!player.inWater && player.velocityY === 0 && player.canJump);

        if (handGroup) {
            const isVisible = handGroup.visible;
            const bobbing = moving && onGround && pointerLocked && !inventoryOpen && isVisible;
            const targetStrength = bobbing ? 1 : 0;
            const lerpSpeed = bobbing ? 10 : 6;
            handBobStrength = THREE.MathUtils.lerp(handBobStrength, targetStrength, Math.min(1, delta * lerpSpeed));
            const idleSpeed = 3.5;
            const walkSpeed = player.isSprinting ? 12 : 9;
            if (isVisible) {
                handBobTime += delta * (bobbing ? walkSpeed : idleSpeed);
                const sinHalf = Math.sin(handBobTime * 0.5);
                const sinFull = Math.sin(handBobTime);
                const sway = sinHalf * 0.09 * handBobStrength;
                const lift = Math.cos(handBobTime) * 0.05 * handBobStrength;
                const push = sinFull * 0.04 * handBobStrength;

                handBobPosition.copy(handBasePosition);
                handBobPosition.x += sway;
                handBobPosition.y += lift - 0.015 * handBobStrength;
                handBobPosition.z += push * 0.6;

                handBobRotation.set(
                    handBaseRotation.x + sinFull * 0.12 * handBobStrength,
                    handBaseRotation.y + Math.sin(handBobTime * 0.3) * 0.06 * handBobStrength,
                    handBaseRotation.z + Math.cos(handBobTime * 0.4) * 0.05 * handBobStrength
                );
            } else {
                handBobPosition.copy(handBasePosition);
                handBobRotation.copy(handBaseRotation);
            }

            handFinalPosition.copy(handBobPosition);
            handFinalRotation.copy(handBobRotation);
        }

        // Track fall distance for damage calculation.  When the player is
        // descending, accumulate the vertical distance fallen.  When
        // ascending or standing on ground reset the fall distance.  If
        // the player lands (transition from not onGround to onGround)
        // apply fall damage based on the accumulated distance.  Damage
        // increases by one heart per four blocks beyond a safe drop of
        // four blocks.
        if (!onGround) {
            // Accumulate fall distance whenever the player is moving downwards.
            if (player.position.y < lastYPosition) {
                fallDistance += (lastYPosition - player.position.y);
            }
        }
        // Landing detection: if the player has just landed, compute fall
        // damage and play a landing sound.  fallDistance is reset above
        // when onGround is true, so use the stored distance from the
        // previous frame.  Only apply damage if the drop was greater
        // than 4 units.  Damage scales with distance.
        if (!wasOnGround && onGround) {
            // Player has just landed.  Use the accumulated fall distance
            // before resetting it.  After computing damage, reset
            // fallDistance so that subsequent jumps start fresh.
            const landedDist = fallDistance;
            if (landedDist > 4) {
                const dmg = Math.ceil((landedDist - 4) / 4);
                dealDamage(dmg);
            }
            // Reset fall distance now that damage has been computed
            fallDistance = 0;
            playRandomStepSound();
        }
        // Play walking step sounds while moving on ground, throttled by interval
        if (onGround && moving) {
            if (time - lastStepSoundTime >= STEP_SOUND_INTERVAL * 1000) {
                playRandomStepSound();
                lastStepSoundTime = time;
            }
        }
        // Update previous ground state
        wasOnGround = onGround;
        // Update camera position.  Copy from player position and apply
        // crouch offset if crouching.  The crouch offset lowers the
        // camera smoothly while crouch is engaged.  The Y position of
        // the player itself remains unchanged so collision detection
        // continues to work correctly.
        camera.position.copy(player.position);
        camera.position.y -= player.crouchOffset;
        camera.position.y += swimBobOffset;
        // Update highlight position based on current look direction.  We
        // raycast into the world to find the targeted block.  If a solid
        // block is hit, position and show the highlight mesh; otherwise
        // hide it.  While breaking, if the target changes or goes out of
        // range the break is cancelled.  If the break timer completes,
        // remove the block, spawn debris and play a dig sound.
        const hit = pickBlock();
        if (hit) {
            highlightMesh.visible = true;
            highlightMesh.position.set(hit.x + 0.5, hit.y + 0.5, hit.z + 0.5);
        } else {
            highlightMesh.visible = false;
        }
        // If we are not currently breaking, ensure the crack overlay is hidden
        if (!isBreaking && cracksMesh) {
            cracksMesh.visible = false;
        }
        if (isBreaking) {
            if (!hit || hit.x !== breakTarget.x || hit.y !== breakTarget.y || hit.z !== breakTarget.z) {
                cancelBreaking();
            } else {
                breakSoundElapsed += delta;
                if (breakSoundElapsed >= breakSoundDelay) {
                    playRandomDigSound(breakTarget.type);
                    resetBreakSoundTimer();
                }
                const elapsed = time - breakStartTime;
                if (cracksMesh) {
                    const duration = currentBreakDuration || BREAK_DURATION;
                    let stage = Math.floor((elapsed / duration) * 10);
                    if (stage < 0) stage = 0;
                    if (stage > 9) stage = 9;
                    cracksMesh.material = destroyMaterials[stage];
                    cracksMesh.position.set(breakTarget.x + 0.5, breakTarget.y + 0.5, breakTarget.z + 0.5);
                }
                if (elapsed >= currentBreakDuration) {
                    removeVoxel(breakTarget.x, breakTarget.y, breakTarget.z);
                    spawnDebris(breakTarget.x, breakTarget.y, breakTarget.z, breakTarget.type);
                    playRandomDigSound(breakTarget.type);
                    cancelBreaking();
                }
            }
        }
        if (leftMouseDown && !isBreaking) {
            startBreaking();
        }
        if (pointerLocked && !inventoryOpen && rightMouseDown) {
            placeHoldCooldown -= delta;
            if (placeHoldCooldown <= 0) {
                if (tryPlaceBlock()) {
                    placeHoldCooldown = PLACE_REPEAT_INTERVAL;
                } else {
                    placeHoldCooldown = PLACE_REPEAT_INTERVAL * 0.5;
                }
            }
        } else if (!rightMouseDown) {
            placeHoldCooldown = 0;
        }
        if (leafDecayQueue.length > 0) {
            processLeafDecay(delta);
        }
        // Animate hand when placing or breaking.  A short animation moves
        // the hand forward/back or rotates it downward, similar to
        // Minecraft.  handAnimTime runs from 0 to 1 over the course of
        // 0.3 seconds.  After completion the animation resets.
        if (handGroup) {
            if (!handGroup.visible) {
                handAnimTime = 0;
                handAnimType = null;
                handGroup.position.copy(handBasePosition);
                handGroup.rotation.copy(handBaseRotation);
            } else {
                if (handAnimType) {
                    const animDuration = handAnimType === 'break' ? 0.36 : 0.28;
                    handAnimTime += delta / animDuration;
                    const t = Math.min(handAnimTime, 1);
                    handFinalPosition.copy(handBobPosition);
                    handFinalRotation.copy(handBobRotation);
                    if (handAnimType === 'break') {
                        const angle = Math.sin(t * Math.PI) * 0.68;
                        handFinalRotation.x -= angle;
                        handFinalRotation.y += Math.sin(t * Math.PI * 0.5) * 0.12;
                        if (handAnimTime >= 1) {
                            if (leftMouseDown && isBreaking) {
                                handAnimTime = 0;
                            } else {
                                handAnimTime = 0;
                                handAnimType = null;
                            }
                        }
                    } else if (handAnimType === 'place') {
                        const offset = Math.sin(t * Math.PI) * 0.42;
                        handFinalPosition.z -= offset;
                        handFinalRotation.x += Math.sin(t * Math.PI) * 0.25;
                        if (handAnimTime >= 1) {
                            if (rightMouseDown && pointerLocked && !inventoryOpen) {
                                handAnimTime = 0;
                            } else {
                                handAnimTime = 0;
                                handAnimType = null;
                            }
                        }
                    }
                } else {
                    handFinalPosition.copy(handBobPosition);
                    handFinalRotation.copy(handBobRotation);
                }
                handGroup.position.copy(handFinalPosition);
                handGroup.rotation.copy(handFinalRotation);
            }
        }
        // Update debris pieces: apply velocity and gravity, update life and
        // remove when expired.  A small gravity value is used here to
        // simulate falling pieces separate from the player's gravity.
        for (let i = debrisPieces.length - 1; i >= 0; i--) {
            const d = debrisPieces[i];
            d.velocity.y -= GRAVITY * delta * 0.5;
            d.mesh.position.addScaledVector(d.velocity, delta);
            d.life -= delta;
            if (d.life <= 0) {
                scene.remove(d.mesh);
                debrisPieces.splice(i, 1);
            }
        }
        // Update dropped items: move them under gravity and check for
        // collection by the player.  This call ensures that spawned
        // items fall to the ground and can be picked up.
        updateDroppedItems(delta);

        // Process a subset of water cells to simulate flowing water.  This
        // spreads newly placed water into adjacent empty blocks over
        // time.  Limiting the number of processed cells per frame
        // prevents the simulation from consuming too much CPU.
        updateFluidSimulation();
        // Frustum culling for chunks: hide chunk groups outside the camera
        // view frustum to improve performance.  A conservative bounding box
        // is computed for each chunk based on its world coordinates.  If
        // the frustum does not intersect the chunk's bounding box, we hide
        // its group.  Otherwise we show it.  This helps avoid drawing
        // chunks that are behind the player or far out of view.
        {
            const projScreenMatrix = new THREE.Matrix4();
            projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            const frustum = new THREE.Frustum();
            frustum.setFromProjectionMatrix(projScreenMatrix);
            for (const chunk of chunkMap.values()) {
                // compute chunk bounding box
                const minX = chunk.cx * CHUNK_SIZE;
                const minZ = chunk.cz * CHUNK_SIZE;
                const maxX = minX + CHUNK_SIZE;
                const maxZ = minZ + CHUNK_SIZE;
                const box = new THREE.Box3(new THREE.Vector3(minX, 0, minZ), new THREE.Vector3(maxX, CHUNK_HEIGHT, maxZ));
                chunk.group.visible = frustum.intersectsBox(box);
            }
        }

        // Render the scene
        renderer.render(scene, camera);

        // Lava damage: apply damage over time when the player's feet are
        // inside a lava block.  Each second spent in lava removes one
        // heart.  lavaAccumulator stores accumulated time in seconds.
        {
            const fx = Math.floor(player.position.x);
            const fy = Math.floor(player.position.y - PLAYER_HEIGHT / 2 + 0.001);
            const fz = Math.floor(player.position.z);
            const entry = voxelMap.get(`${fx},${fy},${fz}`);
            if (entry && entry.type === 'lava') {
                lavaAccumulator += delta;
                if (lavaAccumulator >= 1.0) {
                    const dmg = Math.floor(lavaAccumulator);
                    lavaAccumulator -= dmg;
                    dealDamage(dmg);
                }
            } else {
                lavaAccumulator = 0;
            }
        }

        // Store last Y position for fall damage calculations on the next frame
        lastYPosition = player.position.y;
    }

    // Play a random step or landing sound from the loaded stepSounds array.  If no
    // sounds have finished loading yet, this function safely returns.  When a
    // sound is selected that is already playing, it is stopped before
    // restarting to avoid overlapping the same sound.
    function playRandomStepSound() {
        if (!stepSounds || stepSounds.length === 0) return;
        const index = Math.floor(Math.random() * stepSounds.length);
        const sound = stepSounds[index];
        if (!sound.buffer) {
            // buffer not loaded yet
            return;
        }
        if (sound.isPlaying) {
            sound.stop();
        }
        sound.play();
    }

    // Play a random background music track.  Each track will be loaded via
    // musicLoader and played through the same Audio object.  When a track
    // finishes playing, the onEnded callback triggers this function again to
    // continue playing music indefinitely.
    function playRandomMusic() {
        if (!MUSIC_TRACKS || MUSIC_TRACKS.length === 0) return;
        const url = MUSIC_TRACKS[Math.floor(Math.random() * MUSIC_TRACKS.length)];
        musicLoader.load(url, (buffer) => {
            music.setBuffer(buffer);
            music.setLoop(false);
            // Volume is determined by the global master and music volume
            music.setVolume(masterVolume * musicVolume);
            // assign an ended callback each time we set a new buffer
            music.onEnded = () => {
                playRandomMusic();
            };
            music.play();
        }, undefined, (err) => {
            console.warn('Error loading music', url, err);
        });
    }

    function getHandMaterialForType(type) {
        if (!type || !blockMaterials[type]) {
            return emptyHandMaterial;
        }
        if (!handMaterialCache.has(type)) {
            const mat = blockMaterials[type].clone();
            if (type === 'leaves') {
                mat.depthTest = false;
                mat.depthWrite = false;
                mat.transparent = true;
                mat.alphaTest = 0.5;
                mat.side = THREE.DoubleSide;
            } else {
                mat.depthTest = false;
                mat.depthWrite = false;
            }
            handMaterialCache.set(type, mat);
        }
        return handMaterialCache.get(type);
    }

    // Update the material of the handBlock mesh to reflect the currently
    // selected block type.  This is called whenever the player presses 1‚Äì4.
    function updateHandBlockMaterial() {
        if (!handBlock || !handGroup) return;
        const type = selectableTypes[selectedIndex];
        const available = type ? (inventory[type] || 0) : 0;
        Object.values(handItemMeshes).forEach((mesh) => {
            if (mesh) mesh.visible = false;
        });
        activeHandTool = null;
        handBlock.visible = false;
        handGroup.visible = false;
        if (type && available > 0) {
            handGroup.visible = true;
            if (blockMaterials[type]) {
                handBlock.material = getHandMaterialForType(type);
                handBlock.material.needsUpdate = true;
                handBlock.visible = true;
            } else if (handItemMeshes[type]) {
                handBlock.visible = false;
                handItemMeshes[type].visible = true;
                activeHandTool = type;
            } else {
                handBlock.material = emptyHandMaterial;
                handBlock.material.needsUpdate = true;
                handBlock.visible = false;
                handGroup.visible = false;
            }
        } else {
            handBlock.material = emptyHandMaterial;
            handBlock.material.needsUpdate = true;
            handBlock.visible = false;
            handGroup.visible = false;
        }
        if (typeof updateHotbarSelection === 'function') updateHotbarSelection();
        if (type && available > 0 && typeof showSelectionTooltip === 'function') {
            showSelectionTooltip(type, selectedIndex);
        } else if (selectionTooltip) {
            selectionTooltip.classList.remove('visible');
        }
    }

    function getToolStyle(variant) {
        return TOOL_VARIANT_STYLE[variant] || TOOL_VARIANT_STYLE.wooden;
    }

    function applyToolMaterialSettings(materials, forIcon) {
        const shouldDepthTest = !!forIcon;
        materials.forEach((mat) => {
            mat.depthTest = shouldDepthTest;
            mat.depthWrite = shouldDepthTest;
        });
    }

    function createAxeMesh(options = {}) {
        const { forIcon = false, variant = 'wooden' } = options;
        const style = getToolStyle(variant);
        const group = new THREE.Group();
        const handleMaterial = new THREE.MeshStandardMaterial({ color: 0x8d5e2c, roughness: 0.68, metalness: 0.18, flatShading: true });
        const gripMaterial = new THREE.MeshStandardMaterial({ color: style.wrap, roughness: 0.82, metalness: 0.08, flatShading: true });
        const headCoreMaterial = new THREE.MeshStandardMaterial({ color: style.headPrimary, roughness: 0.35, metalness: 0.88, emissive: style.emissive, emissiveIntensity: 0.24, flatShading: true });
        const headPlateMaterial = new THREE.MeshStandardMaterial({ color: style.headSecondary, roughness: 0.18, metalness: 0.95, emissive: style.emissive, emissiveIntensity: 0.3, flatShading: true });
        const edgeMaterial = new THREE.MeshStandardMaterial({ color: style.edge, roughness: 0.06, metalness: 1.0, flatShading: true });
        applyToolMaterialSettings([handleMaterial, gripMaterial, headCoreMaterial, headPlateMaterial, edgeMaterial], forIcon);

        const shaft = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.74, 0.09), handleMaterial);
        shaft.position.set(-0.05, -0.02, 0);
        shaft.rotation.z = THREE.MathUtils.degToRad(6);
        const grip = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, 0.1), gripMaterial);
        grip.position.set(-0.05, -0.34, -0.005);
        const pommel = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, 0.12), gripMaterial);
        pommel.position.set(-0.05, -0.42, 0.01);

        const headBase = new THREE.Mesh(new THREE.BoxGeometry(0.48, 0.28, 0.18), headCoreMaterial);
        headBase.position.set(0.22, 0.26, 0);
        const headInset = new THREE.Mesh(new THREE.BoxGeometry(0.34, 0.18, 0.2), headPlateMaterial);
        headInset.position.set(0.36, 0.32, 0);
        const blade = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.3, 0.26), headPlateMaterial);
        blade.position.set(0.54, 0.26, 0);
        const bladeEdge = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.3, 0.28), edgeMaterial);
        bladeEdge.position.set(0.62, 0.26, 0);
        const lowerNotch = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.12, 0.2), headCoreMaterial.clone());
        lowerNotch.position.set(0.18, 0.06, 0);
        lowerNotch.rotation.z = -Math.PI / 6;

        group.add(shaft, grip, pommel, headBase, headInset, blade, bladeEdge, lowerNotch);
        group.rotation.set(-Math.PI / 3.2, Math.PI / 4, Math.PI / 16);
        group.traverse((child) => {
            if (child.isMesh) {
                child.renderOrder = 31;
                child.castShadow = false;
                child.receiveShadow = false;
            }
        });
        return group;
    }

    function createStickMesh(options = {}) {
        const { forIcon = false } = options;
        const group = new THREE.Group();
        const coreMaterial = new THREE.MeshStandardMaterial({ color: 0x9f6b36, roughness: 0.7, metalness: 0.12, flatShading: true });
        const highlightMaterial = new THREE.MeshStandardMaterial({ color: 0xcb9451, roughness: 0.6, metalness: 0.15, flatShading: true });
        const shouldDepthTest = !!forIcon;
        [coreMaterial, highlightMaterial].forEach((mat) => {
            mat.depthTest = shouldDepthTest;
            mat.depthWrite = shouldDepthTest;
        });

        const shaft = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.62, 0.06), coreMaterial);
        shaft.rotation.z = THREE.MathUtils.degToRad(-6);
        const sheen = new THREE.Mesh(new THREE.BoxGeometry(0.028, 0.6, 0.028), highlightMaterial);
        sheen.position.set(0.022, -0.02, 0.022);
        sheen.rotation.z = THREE.MathUtils.degToRad(-6);

        group.add(shaft, sheen);
        group.rotation.set(-Math.PI / 3.6, Math.PI / 5.6, Math.PI / 18);
        group.traverse((child) => {
            if (child.isMesh) {
                child.renderOrder = 31;
                child.castShadow = false;
                child.receiveShadow = false;
            }
        });
        return group;
    }

    function createPickaxeMesh(options = {}) {
        const { forIcon = false, variant = 'wooden' } = options;
        const style = getToolStyle(variant);
        const group = new THREE.Group();
        const handleMaterial = new THREE.MeshStandardMaterial({ color: 0x84532a, roughness: 0.68, metalness: 0.18, flatShading: true });
        const wrapMaterial = new THREE.MeshStandardMaterial({ color: style.wrap, roughness: 0.82, metalness: 0.08, flatShading: true });
        const headCoreMaterial = new THREE.MeshStandardMaterial({ color: style.headPrimary, roughness: 0.3, metalness: 0.92, emissive: style.emissive, emissiveIntensity: 0.22, flatShading: true });
        const headPlateMaterial = new THREE.MeshStandardMaterial({ color: style.headSecondary, roughness: 0.18, metalness: 0.95, emissive: style.emissive, emissiveIntensity: 0.28, flatShading: true });
        const tipMaterial = new THREE.MeshStandardMaterial({ color: style.edge, roughness: 0.08, metalness: 1.0, flatShading: true });
        applyToolMaterialSettings([handleMaterial, wrapMaterial, headCoreMaterial, headPlateMaterial, tipMaterial], forIcon);

        const haft = new THREE.Mesh(new THREE.BoxGeometry(0.085, 0.82, 0.085), handleMaterial);
        haft.rotation.z = THREE.MathUtils.degToRad(8);
        haft.position.set(-0.06, -0.05, 0);
        const gripWrap = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.22, 0.1), wrapMaterial);
        gripWrap.position.set(-0.06, -0.34, 0.01);
        const pommelCap = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, 0.12), wrapMaterial);
        pommelCap.position.set(-0.06, -0.41, 0.02);

        const headBridge = new THREE.Mesh(new THREE.BoxGeometry(0.68, 0.14, 0.2), headCoreMaterial);
        headBridge.position.set(0.28, 0.32, 0);
        const headFace = new THREE.Mesh(new THREE.BoxGeometry(0.64, 0.12, 0.26), headPlateMaterial);
        headFace.position.set(0.3, 0.34, 0);
        const leftProng = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.12, 0.24), headPlateMaterial);
        leftProng.position.set(-0.02, 0.34, 0);
        leftProng.rotation.z = THREE.MathUtils.degToRad(14);
        const rightProng = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.12, 0.24), headPlateMaterial);
        rightProng.position.set(0.52, 0.34, 0);
        rightProng.rotation.z = THREE.MathUtils.degToRad(-10);
        const leftTip = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.1, 0.2), tipMaterial);
        leftTip.position.set(-0.14, 0.36, 0);
        leftTip.rotation.z = THREE.MathUtils.degToRad(20);
        const rightTip = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.1, 0.22), tipMaterial);
        rightTip.position.set(0.74, 0.32, 0);
        rightTip.rotation.z = THREE.MathUtils.degToRad(-18);

        group.add(haft, gripWrap, pommelCap, headBridge, headFace, leftProng, rightProng, leftTip, rightTip);
        group.rotation.set(-Math.PI / 3.4, Math.PI / 4.1, -Math.PI / 16);
        group.traverse((child) => {
            if (child.isMesh) {
                child.renderOrder = 31;
                child.castShadow = false;
                child.receiveShadow = false;
            }
        });
        return group;
    }

    function createSwordMesh(options = {}) {
        const { forIcon = false, variant = 'wooden' } = options;
        const style = getToolStyle(variant);
        const group = new THREE.Group();
        const handleMaterial = new THREE.MeshStandardMaterial({ color: 0x7a4a1f, roughness: 0.7, metalness: 0.2, flatShading: true });
        const wrapMaterial = new THREE.MeshStandardMaterial({ color: style.wrap, roughness: 0.82, metalness: 0.12, flatShading: true });
        const guardMaterial = new THREE.MeshStandardMaterial({ color: style.headPrimary, roughness: 0.35, metalness: 0.85, emissive: style.emissive, emissiveIntensity: 0.2, flatShading: true });
        const bladeMaterial = new THREE.MeshStandardMaterial({ color: style.headSecondary, roughness: 0.16, metalness: 0.96, emissive: style.emissive, emissiveIntensity: 0.28, flatShading: true });
        const edgeMaterial = new THREE.MeshStandardMaterial({ color: style.edge, roughness: 0.08, metalness: 1.0, flatShading: true });
        applyToolMaterialSettings([handleMaterial, wrapMaterial, guardMaterial, bladeMaterial, edgeMaterial], forIcon);

        const grip = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.24, 0.1), wrapMaterial);
        grip.position.set(0, -0.28, 0);
        const handle = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.28, 0.08), handleMaterial);
        handle.position.set(0, -0.5, 0);
        const pommel = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.08, 0.14), wrapMaterial);
        pommel.position.set(0, -0.62, 0);
        const guard = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.08, 0.18), guardMaterial);
        guard.position.set(0, -0.12, 0);
        const bladeCore = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.96, 0.08), bladeMaterial);
        bladeCore.position.set(0, 0.4, 0);
        const bladeEdge = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.96, 0.02), edgeMaterial);
        bladeEdge.position.set(0, 0.4, 0.05);
        const tip = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.18, 0.06), bladeMaterial);
        tip.position.set(0, 0.94, 0);
        tip.scale.set(0.5, 1, 1);

        group.add(grip, handle, pommel, guard, bladeCore, bladeEdge, tip);
        group.rotation.set(-Math.PI / 3.3, Math.PI / 3.8, Math.PI / 20);
        group.traverse((child) => {
            if (child.isMesh) {
                child.renderOrder = 31;
                child.castShadow = false;
                child.receiveShadow = false;
            }
        });
        return group;
    }

    function createShovelMesh(options = {}) {
        const { forIcon = false, variant = 'wooden' } = options;
        const style = getToolStyle(variant);
        const group = new THREE.Group();
        const handleMaterial = new THREE.MeshStandardMaterial({ color: 0x84532a, roughness: 0.7, metalness: 0.18, flatShading: true });
        const gripMaterial = new THREE.MeshStandardMaterial({ color: style.wrap, roughness: 0.82, metalness: 0.1, flatShading: true });
        const scoopMaterial = new THREE.MeshStandardMaterial({ color: style.headSecondary, roughness: 0.22, metalness: 0.92, emissive: style.emissive, emissiveIntensity: 0.26, flatShading: true });
        const edgeMaterial = new THREE.MeshStandardMaterial({ color: style.edge, roughness: 0.08, metalness: 1.0, flatShading: true });
        applyToolMaterialSettings([handleMaterial, gripMaterial, scoopMaterial, edgeMaterial], forIcon);

        const shaft = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.92, 0.08), handleMaterial);
        shaft.rotation.z = THREE.MathUtils.degToRad(-6);
        shaft.position.set(-0.04, -0.04, 0);
        const grip = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.2, 0.12), gripMaterial);
        grip.position.set(-0.04, -0.46, 0.02);
        const pommel = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.08, 0.16), gripMaterial);
        pommel.position.set(-0.04, -0.56, 0.02);

        const scoopBack = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.24, 0.12), scoopMaterial);
        scoopBack.position.set(0.32, 0.36, 0);
        scoopBack.rotation.z = THREE.MathUtils.degToRad(-10);
        const scoopFace = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.22, 0.08), scoopMaterial.clone());
        scoopFace.position.set(0.38, 0.4, 0);
        const scoopEdge = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.06, 0.16), edgeMaterial);
        scoopEdge.position.set(0.4, 0.28, 0);

        group.add(shaft, grip, pommel, scoopBack, scoopFace, scoopEdge);
        group.rotation.set(-Math.PI / 3.5, Math.PI / 4, -Math.PI / 14);
        group.traverse((child) => {
            if (child.isMesh) {
                child.renderOrder = 31;
                child.castShadow = false;
                child.receiveShadow = false;
            }
        });
        return group;
    }

    const TOOL_FACTORIES = {
        axe: createAxeMesh,
        pickaxe: createPickaxeMesh,
        sword: createSwordMesh,
        shovel: createShovelMesh
    };

    function refreshAllHotbarSlots() {
        if (!hotbarSlots || hotbarSlots.length === 0) return;
        for (let i = 0; i < hotbarSlots.length; i++) {
            refreshHotbarSlot(i);
        }
    }

    function refreshHotbarSlot(index) {
        const slot = hotbarSlots[index];
        if (!slot) return;
        const img = slot.querySelector('img');
        const countLabel = slot.querySelector('.hotbar-count');
        const type = selectableTypes[index];
        const count = type ? Math.min(inventory[type] || 0, getStackLimit(type)) : 0;
        if (img) {
            if (type && hotbarIcons[type]) {
                img.src = hotbarIcons[type];
                img.alt = blockNames[type] || type;
                img.style.display = 'block';
            } else {
                if (type && !iconsReady) {
                    onIconsReady(() => refreshHotbarSlot(index));
                }
                img.removeAttribute('src');
                img.style.display = 'none';
            }
        }
        slot.dataset.type = type || '';
        slot.dataset.count = count;
        if (countLabel) {
            if (type && TOOL_TYPES.has(type)) {
                countLabel.textContent = '';
            } else {
                countLabel.textContent = count > 0 ? count.toString() : '';
            }
        }
        slot.classList.toggle('empty', !type || count <= 0);
    }

    function refreshHotbarSlotForType(type) {
        if (!type) return;
        const idx = selectableTypes.indexOf(type);
        if (idx >= 0) refreshHotbarSlot(idx);
    }

    function assignHotbarSlot(index, type) {
        if (index < 0 || index >= selectableTypes.length) return;
        const normalizedType = (type && isHotbarAssignable(type)) ? type : null;
        const previousSelectedType = selectableTypes[selectedIndex];
        selectableTypes[index] = normalizedType;
        refreshHotbarSlot(index);
        const available = normalizedType ? (inventory[normalizedType] || 0) : 0;
        if (normalizedType && available > 0 && (!previousSelectedType || selectedIndex === index)) {
            selectedIndex = index;
            updateHandBlockMaterial();
        } else if (!normalizedType && index === selectedIndex) {
            const nextFilled = selectableTypes.findIndex((value) => value && (inventory[value] || 0) > 0);
            if (nextFilled >= 0) {
                selectedIndex = nextFilled;
            }
            updateHandBlockMaterial();
        } else if (index === selectedIndex) {
            updateHandBlockMaterial();
        } else {
            updateHotbarSelection();
        }
    }

    function ensureHotbarHasType(type) {
        if (!type || !isHotbarAssignable(type)) return -1;
        let idx = selectableTypes.indexOf(type);
        if (idx === -1) {
            idx = selectableTypes.indexOf(null);
            if (idx !== -1) {
                assignHotbarSlot(idx, type);
            }
        } else {
            refreshHotbarSlot(idx);
        }
        return idx;
    }

    function canAcceptDraggedItem(event) {
        if (!event || !event.dataTransfer) return false;
        const types = event.dataTransfer.types;
        if (!types) return false;
        if (typeof types.includes === 'function') {
            return types.includes(HOTBAR_DRAG_MIME) || types.includes('text/plain');
        }
        if (typeof types.indexOf === 'function') {
            return types.indexOf(HOTBAR_DRAG_MIME) !== -1 || types.indexOf('text/plain') !== -1;
        }
        return false;
    }

    function getDraggedItemType(event) {
        if (!event || !event.dataTransfer) return null;
        const type = event.dataTransfer.getData(HOTBAR_DRAG_MIME) || event.dataTransfer.getData('text/plain');
        if (!type || !blockNames[type]) return null;
        return type;
    }

    // Initialize the hotbar by creating DOM elements for each selectable type.
    // This should be called once during init().  Each slot shows an icon
    // corresponding to the block type, and the currently selected slot is
    // highlighted.
    function initHotbar() {
        const bar = document.getElementById('hotbar');
        if (!bar) return;
        // Clear any existing children in case of reinitialisation
        while (bar.firstChild) bar.removeChild(bar.firstChild);
        hotbarSlots = [];
        for (let i = 0; i < selectableTypes.length; i++) {
            const slot = document.createElement('div');
            slot.className = 'hotbar-slot empty';
            slot.dataset.index = i;
            slot.dataset.key = i + 1;
            slot.dataset.type = '';
            const img = document.createElement('img');
            img.alt = '';
            img.draggable = false;
            img.addEventListener('dragstart', (event) => event.preventDefault());
            slot.appendChild(img);
            const count = document.createElement('span');
            count.className = 'hotbar-count';
            slot.appendChild(count);

            slot.addEventListener('dragover', (event) => {
                if (!canAcceptDraggedItem(event)) return;
                event.preventDefault();
                if (event.dataTransfer) {
                    event.dataTransfer.dropEffect = 'copy';
                }
                slot.classList.add('drag-over');
            });
            slot.addEventListener('dragleave', () => {
                slot.classList.remove('drag-over');
            });
            slot.addEventListener('drop', (event) => {
                event.preventDefault();
                slot.classList.remove('drag-over');
                const draggedType = getDraggedItemType(event);
                if (!draggedType) return;
                assignHotbarSlot(i, draggedType);
            });
            slot.addEventListener('click', () => {
                if (!selectableTypes[i]) return;
                selectedIndex = i;
                updateHandBlockMaterial();
            });
            slot.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                if (!selectableTypes[i]) return;
                assignHotbarSlot(i, null);
            });

            bar.appendChild(slot);
            hotbarSlots.push(slot);
            refreshHotbarSlot(i);
        }
        updateHotbarSelection();

        // Reference the selection tooltip element.  It's a singleton in the
        // DOM.  This ensures we capture it once for later positioning and
        // updates.  The tooltip will remain hidden until explicitly shown.
        selectionTooltip = document.getElementById('selectionTooltip');
    }

    // Highlight the currently selected hotbar slot.  Called whenever
    // selectedIndex changes.
    function updateHotbarSelection() {
        if (!hotbarSlots || hotbarSlots.length === 0) return;
        for (let i = 0; i < hotbarSlots.length; i++) {
            const slot = hotbarSlots[i];
            if (i === selectedIndex) {
                slot.classList.add('selected');
            } else {
                slot.classList.remove('selected');
            }
        }
    }

    // --- Health UI helpers ---
    // Update the heart display based on the player's current health.  A
    // filled heart is represented by a red unicode heart.  Empty hearts
    // are grey.  The hearts container is cleared and repopulated on each
    // call.
    function updateHearts() {
        const container = document.getElementById('heartContainer');
        if (!container) return;
        // Clear existing hearts
        container.innerHTML = '';
        for (let i = 0; i < maxHealth; i++) {
            const span = document.createElement('span');
            span.classList.add('heart');
            if (i < health) {
                span.textContent = '‚ù§';
            } else {
                span.textContent = '‚ù§';
                span.classList.add('empty');
            }
            container.appendChild(span);
        }
    }

    // --- Inventory UI helpers ---
    // Build the inventory grid.  This function creates grid elements for
    // every block type known to the game (as defined in blockNames).  The
    // grid entries display the block's icon and its count in the
    // inventory.  Clicking an entry will select that block for placement
    // by changing selectedIndex and updating the hotbar selection.  The
    // search field filters the visible items based on the block name.
    function initInventoryUI() {
        const overlay = document.getElementById('inventoryOverlay');
        const grid = document.getElementById('inventoryGrid');
        const backpackGrid = document.getElementById('backpackGrid');
        const searchInput = document.getElementById('inventorySearch');
        const closeBtn = document.getElementById('closeInventory');
        const emptyState = document.getElementById('inventoryEmptyState');
        const searchTab = document.getElementById('inventorySearchTab');
        const backpackTab = document.getElementById('inventoryBackpackTab');
        if (!overlay || !grid || !backpackGrid || !searchInput || !closeBtn || !emptyState || !searchTab || !backpackTab) return;
        searchInput.addEventListener('input', () => {
            updateInventoryUI();
        });
        closeBtn.addEventListener('click', () => {
            toggleInventory();
        });
        searchTab.addEventListener('click', () => {
            setInventoryView('search');
        });
        backpackTab.addEventListener('click', () => {
            setInventoryView('backpack');
        });
        grid.addEventListener('dragstart', (event) => {
            if (event.target && event.target.tagName === 'IMG') {
                event.preventDefault();
            }
        });
        backpackGrid.addEventListener('dragstart', (event) => {
            if (event.target && event.target.tagName === 'IMG') {
                event.preventDefault();
            }
        });
        initCraftingUI();
        initRecipeBookUI();
        setInventoryView(activeInventoryView);
        updateInventoryUI();
    }

    function createInventorySlot(type, options = {}) {
        const { closeOnClick = false } = options;
        const slot = document.createElement('div');
        slot.className = 'inv-slot';
        const img = document.createElement('img');
        slot.appendChild(img);
        const countSpan = document.createElement('span');
        countSpan.className = 'inv-count';
        slot.appendChild(countSpan);

        if (!type) {
            slot.classList.add('empty');
            slot.dataset.type = '';
            slot.draggable = false;
            img.style.display = 'none';
            return { slot, countSpan, img };
        }

        slot.dataset.type = type;
        slot.draggable = true;
        if (hotbarIcons[type]) {
            img.src = hotbarIcons[type];
        } else if (!iconsReady) {
            onIconsReady(() => {
                if (hotbarIcons[type]) {
                    img.src = hotbarIcons[type];
                    img.style.display = 'block';
                }
            });
        }
        img.alt = blockNames[type] || type;
        img.draggable = false;
        img.style.pointerEvents = 'none';
        img.addEventListener('dragstart', (event) => event.preventDefault());
        if (!hotbarIcons[type]) {
            img.style.display = 'none';
        }

        slot.addEventListener('click', () => {
            const idx = selectableTypes.indexOf(type);
            if (idx >= 0) {
                selectedIndex = idx;
                updateHotbarSelection();
                updateHandBlockMaterial();
            }
            if (closeOnClick) toggleInventory();
        });
        slot.addEventListener('dragstart', (event) => {
            if (!event.dataTransfer) return;
            event.dataTransfer.setData(HOTBAR_DRAG_MIME, type);
            event.dataTransfer.setData('text/plain', type);
            event.dataTransfer.effectAllowed = 'copy';
        });
        return { slot, countSpan, img };
    }

    // Refresh the inventory grid contents.  This is called whenever the
    // inventory overlay is opened or when the search/filter changes or
    // when item counts are updated.  Slots are regenerated to reflect the
    // discovered items while keeping undiscovered ones hidden.
    function updateInventoryUI() {
        const grid = document.getElementById('inventoryGrid');
        const searchInput = document.getElementById('inventorySearch');
        const emptyState = document.getElementById('inventoryEmptyState');
        if (grid && searchInput && emptyState) {
            const query = searchInput.value.trim().toLowerCase();
            grid.innerHTML = '';
            const fragment = document.createDocumentFragment();
            let visibleCount = 0;
            BLOCK_TYPE_ORDER.forEach((type) => {
                if (!discoveredTypes.has(type)) return;
                const label = (blockNames[type] || type).toLowerCase();
                if (query && !label.includes(query)) return;
                const { slot, countSpan } = createInventorySlot(type);
                const count = inventory[type] || 0;
                const displayCount = Math.min(count, getStackLimit(type));
                countSpan.textContent = displayCount > 0 ? displayCount.toString() : '';
                fragment.appendChild(slot);
                visibleCount++;
            });
            if (visibleCount === 0) {
                emptyState.style.display = 'block';
                emptyState.textContent = discoveredTypes.size === 0
                    ? 'Collect blocks to fill your inventory.'
                    : 'No items match your search.';
            } else {
                emptyState.style.display = 'none';
                emptyState.textContent = '';
            }
            grid.appendChild(fragment);
        }

        const backpackGrid = document.getElementById('backpackGrid');
        if (backpackGrid) {
            backpackGrid.innerHTML = '';
            const items = BLOCK_TYPE_ORDER.filter((type) => discoveredTypes.has(type));
            const rows = Math.max(3, Math.ceil(items.length / 9));
            const totalSlots = rows * 9;
            backpackGrid.style.gridTemplateRows = `repeat(${rows}, 58px)`;
            for (let i = 0; i < totalSlots; i++) {
                const type = items[i] || null;
                const { slot, countSpan } = createInventorySlot(type);
                if (type) {
                    const count = inventory[type] || 0;
                    const displayCount = Math.min(count, getStackLimit(type));
                    countSpan.textContent = displayCount > 1 ? displayCount.toString() : (displayCount === 1 ? '1' : '');
                } else {
                    countSpan.textContent = '';
                }
                backpackGrid.appendChild(slot);
            }
        }

        recalculateCraftingResult();
    }

    // Toggle the inventory overlay.  When opening, release pointer lock
    // and pause the game.  When closing, reapply pointer lock and
    // resume.  Inventory toggling is bound to the 'E' key.
    function toggleInventory() {
        const overlay = document.getElementById('inventoryOverlay');
        const bar = document.getElementById('hotbar');
        if (!overlay) return;
        leftMouseDown = false;
        rightMouseDown = false;
        placeHoldCooldown = 0;
        cancelBreaking();
        if (!inventoryOpen) {
            inventoryOpen = true;
            overlay.classList.add('open');
            setInventoryView('search');
            updateInventoryUI();
            setRecipeBookOpen(false);
            setRecipeBookActive(null);
            player.moveForward = false;
            player.moveBackward = false;
            player.moveLeft = false;
            player.moveRight = false;
            player.isSprinting = false;
            player.isCrouching = false;
            player.crouchOffset = 0;
            player.jumpHeld = false;
            if (bar) {
                bar.classList.add('visible');
                bar.classList.add('interactive');
            }
            // Unlock pointer if locked
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
            // Pause the game if not already paused
            if (!window.isPaused && typeof window.showPauseMenu === 'function') {
                // Instead of showing pause menu, just set paused state
                window.isPaused = true;
            }
        } else {
            inventoryOpen = false;
            overlay.classList.remove('open');
            setRecipeBookOpen(false);
            setRecipeBookActive(null);
            if (bar) {
                bar.classList.remove('interactive');
                if (pointerLocked) bar.classList.add('visible');
                else bar.classList.remove('visible');
            }
            // Restore pointer lock
            if (!document.pointerLockElement) {
                const canvas = renderer.domElement;
                if (canvas.requestPointerLock) canvas.requestPointerLock();
            }
            // Resume game (unpause) if it was paused by inventory
            if (window.isPaused && typeof window.hidePauseMenu === 'function') {
                // Only set paused false if pause menu isn't open
                if (!window.pauseMenuElement || window.pauseMenuElement.style.display !== 'flex') {
                    window.isPaused = false;
                }
            }
        }
        if (!inventoryOpen) {
            const searchInput = document.getElementById('inventorySearch');
            if (searchInput) searchInput.blur();
        }
    }
    // Apply damage to the player.  Decreases health by the given
    // amount (minimum 1).  Plays a random damage sound and updates
    // hearts.  If health reaches zero, triggers death.
    function dealDamage(amount) {
        amount = Math.max(1, Math.floor(amount));
        health -= amount;
        if (health < 0) health = 0;
        // Play random damage sound if any health remains
        if (health > 0 && damageSounds.length > 0) {
            const idx = Math.floor(Math.random() * damageSounds.length);
            try {
                damageSounds[idx].currentTime = 0;
                const sfxScale = underwaterAudioActive ? UNDERWATER_HTML_ATTENUATION : 1;
                damageSounds[idx].volume = 0.6 * masterVolume * sfxVolume * sfxScale;
                damageSounds[idx].playbackRate = underwaterAudioActive ? UNDERWATER_SFX_PITCH : 1;
                damageSounds[idx].play();
            } catch (e) {}
        }
        updateHearts();
        if (health <= 0) {
            die();
        }
    }
    // Handle player death.  Show the death screen, play the death
    // sound and freeze the game.  Exits pointer lock and marks the game
    // as paused so the world stops updating.  The camera is slightly
    // tilted for dramatic effect.
    function die() {
        // Play death sound once
        if (deathSound) {
            try {
                deathSound.currentTime = 0;
                const sfxScale = underwaterAudioActive ? UNDERWATER_HTML_ATTENUATION : 1;
                deathSound.volume = 0.7 * masterVolume * sfxVolume * sfxScale;
                deathSound.playbackRate = underwaterAudioActive ? UNDERWATER_SFX_PITCH : 1;
                deathSound.play();
            } catch (e) {}
        }
        // Show death screen overlay
        const deathEl = document.getElementById('deathScreen');
        if (deathEl) {
            deathEl.style.display = 'flex';
        }
        // Tilt the camera sideways
        camera.rotation.z = Math.PI / 2;
        // Pause the game
        isPaused = true;
        window.isPaused = true;
        // Exit pointer lock
        if (document.pointerLockElement) {
            document.exitPointerLock();
        }
    }
    // Respawn the player after death.  Restores full health, resets
    // position and clears the camera tilt.  Hides the death screen and
    // resumes the game.
    function respawn() {
        health = maxHealth;
        updateHearts();
        // Reset camera tilt
        camera.rotation.z = 0;
        // Reset player position: find highest block at spawn (0,0)
        const groundY = getHighestBlockY(0, 0);
        player.position.set(0, (groundY + 1) + PLAYER_HEIGHT/2, 0);
        player.velocityY = 0;
        // Hide death screen
        const deathEl = document.getElementById('deathScreen');
        if (deathEl) {
            deathEl.style.display = 'none';
        }
        // Resume game
        isPaused = false;
        window.isPaused = false;
        // Request pointer lock again
        const canvas = document.querySelector('canvas');
        if (canvas && !document.pointerLockElement) {
            if (canvas.requestPointerLock) canvas.requestPointerLock();
        }
    }

    // Expose health functions on the global object so that the pause
    // overlay and other scripts can trigger respawn when the death
    // screen buttons are clicked.  Without this export the functions
    // would be scoped to this closure and inaccessible.
    window.updateHearts = updateHearts;
    window.dealDamage   = dealDamage;
    window.respawn      = respawn;

    // Display a tooltip above the selected hotbar slot with the block name
    // and number key.  The tooltip appears for a short duration then fades
    // away.  It is repositioned based on the selected slot's screen
    // coordinates.  If another selection happens before the previous
    // tooltip disappears, the old timer is cleared and a new one starts.
    function showSelectionTooltip(type, index) {
        if (!selectionTooltip || !hotbarSlots || index < 0 || index >= hotbarSlots.length) return;
        // Cancel any existing timeout so the tooltip persists for the full duration
        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
        // Set the tooltip text
        const displayName = blockNames[type] || type;
        selectionTooltip.textContent = `${displayName} (${index + 1})`;
        // Position the tooltip relative to the selected slot
        const slot = hotbarSlots[index];
        const rect = slot.getBoundingClientRect();
        selectionTooltip.style.left = `${rect.left + rect.width / 2}px`;
        selectionTooltip.style.top  = `${rect.top - 6}px`;
        // Translate so that the tooltip is centred horizontally and appears above the slot
        selectionTooltip.style.transform = 'translate(-50%, -100%)';
        // Show the tooltip
        selectionTooltip.classList.add('visible');
        // Hide the tooltip after one second
        tooltipTimeout = setTimeout(() => {
            selectionTooltip.classList.remove('visible');
        }, 1000);
    }

    // Begin breaking the block currently under the crosshair.  The break
    // target is stored and a timer is started.  Unbreakable blocks (such
    // as bedrock) are ignored.  If no block is targeted nothing happens.
    function resetBreakSoundTimer() {
        breakSoundElapsed = 0;
        breakSoundDelay = BREAK_SOUND_MIN + Math.random() * (BREAK_SOUND_MAX - BREAK_SOUND_MIN);
    }

    function startBreaking() {
        if (isBreaking) return false;
        if (!pointerLocked || inventoryOpen) return false;
        const hit = pickBlock();
        if (!hit || hit.type === 'bedrock') return false;
        isBreaking = true;
        breakTarget = hit;
        currentBreakDuration = computeBreakDuration(hit.type);
        breakStartTime = performance.now();
        resetBreakSoundTimer();
        breakSoundElapsed = 0;
        handAnimTime = 0;
        handAnimType = 'break';
        playRandomDigSound(hit.type);
        if (cracksMesh) {
            cracksMesh.visible = true;
            cracksMesh.position.set(hit.x + 0.5, hit.y + 0.5, hit.z + 0.5);
            cracksMesh.material = destroyMaterials[0];
        }
        return true;
    }

    // Cancel the current breaking action, if any.
    function cancelBreaking() {
        isBreaking = false;
        breakTarget = null;
        breakStartTime = 0;
        currentBreakDuration = BREAK_DURATION;
        breakSoundElapsed = 0;
        breakSoundDelay = BREAK_SOUND_MAX;
        // Hide cracks overlay when breaking stops
        if (cracksMesh) {
            cracksMesh.visible = false;
        }
    }

    function computeBreakDuration(targetType) {
        let duration = BREAK_DURATION;
        const heldType = selectableTypes[selectedIndex];
        const heldCount = heldType ? (inventory[heldType] || 0) : 0;
        if (targetType === 'leaves') {
            duration = Math.min(duration, 80);
        }
        const toolInfo = (heldCount > 0) ? TOOL_STATS[heldType] : null;
        if (toolInfo) {
            const effectiveSet = TOOL_EFFECTIVE_TYPES[toolInfo.kind] || null;
            if (effectiveSet && effectiveSet.has(targetType)) {
                const speed = TOOL_TIER_SPEED[toolInfo.tier] || 0.65;
                duration *= speed;
            } else {
                const penalty = TOOL_TIER_PENALTY[toolInfo.tier] || 1.35;
                duration *= penalty;
            }
        }
        return Math.max(80, duration);
    }

    // Attempt to place a block adjacent to the currently targeted block.  The
    // new block is placed on the face indicated by the hit normal.  If the
    // destination is occupied or would intersect the player, nothing happens.
    function tryPlaceBlock() {
        if (inventoryOpen) return false;
        const hit = pickBlock();
        if (!hit) return false;
        const px = hit.x + hit.normal.x;
        const py = hit.y + hit.normal.y;
        const pz = hit.z + hit.normal.z;
        const key = `${px},${py},${pz}`;
        const existing = voxelMap.get(key);
        if (existing && existing.type !== 'water') return false;
        // Don't place into the world outside of bounds (negative y) or above limit
        if (py < 0 || py >= CHUNK_HEIGHT) return false;
        // Prevent placing inside player's bounding box
        const playerBottom = player.position.y - PLAYER_HEIGHT/2;
        const playerTop    = player.position.y + PLAYER_HEIGHT/2;
        const bx = px + 0.5;
        const by = py + 0.5;
        const bz = pz + 0.5;
        if (Math.abs(bx - player.position.x) < 0.4 && Math.abs(bz - player.position.z) < 0.4 && by + 0.5 > playerBottom && py < playerTop) {
            return false;
        }
        const type = selectableTypes[selectedIndex];
        if (!type || !blockMaterials[type]) return false;
        if (!inventory[type] || inventory[type] <= 0) return false;
        if (existing && existing.type === 'water') {
            removeVoxel(px, py, pz);
        }
        placeVoxel(px, py, pz, type);
        // Play a placement sound using the same dig sound categories.  This
        // provides audio feedback when blocks are placed, similar to
        // Minecraft.  We reuse playRandomDigSound() which categorises
        // sounds by block type.
        playRandomDigSound(type);
        // Start place animation
        handAnimTime = 0;
        handAnimType = 'place';
        removeItemFromInventory(type, 1);
        return true;
    }

    function hasSupportingLog(x, y, z) {
        for (let dx = -LEAF_DECAY_RADIUS; dx <= LEAF_DECAY_RADIUS; dx++) {
            for (let dy = -LEAF_DECAY_RADIUS; dy <= LEAF_DECAY_RADIUS; dy++) {
                for (let dz = -LEAF_DECAY_RADIUS; dz <= LEAF_DECAY_RADIUS; dz++) {
                    const distSq = dx * dx + dy * dy + dz * dz;
                    if (distSq > LEAF_DECAY_RADIUS * LEAF_DECAY_RADIUS) continue;
                    const entry = voxelMap.get(`${x + dx},${y + dy},${z + dz}`);
                    if (entry && entry.type === 'wood') {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function scheduleLeafDecay(x, y, z, delayOffset = 0) {
        const key = `${x},${y},${z}`;
        if (leafDecayScheduled.has(key)) return;
        const entry = voxelMap.get(key);
        if (!entry || entry.type !== 'leaves') return;
        const timer = 0.35 + Math.random() * 0.3 + delayOffset;
        const record = { x, y, z, timer };
        leafDecayScheduled.set(key, record);
        leafDecayQueue.push(record);
    }

    function scheduleLeavesAround(x, y, z) {
        let index = 0;
        for (let dx = -LEAF_DECAY_RADIUS; dx <= LEAF_DECAY_RADIUS; dx++) {
            for (let dy = -LEAF_DECAY_RADIUS; dy <= LEAF_DECAY_RADIUS; dy++) {
                for (let dz = -LEAF_DECAY_RADIUS; dz <= LEAF_DECAY_RADIUS; dz++) {
                    const distSq = dx * dx + dy * dy + dz * dz;
                    if (distSq > LEAF_DECAY_RADIUS * LEAF_DECAY_RADIUS) continue;
                    const lx = x + dx;
                    const ly = y + dy;
                    const lz = z + dz;
                    const entry = voxelMap.get(`${lx},${ly},${lz}`);
                    if (!entry || entry.type !== 'leaves') continue;
                    if (hasSupportingLog(lx, ly, lz)) continue;
                    scheduleLeafDecay(lx, ly, lz, index * 0.08);
                    index++;
                }
            }
        }
    }

    function processLeafDecay(delta) {
        for (let i = leafDecayQueue.length - 1; i >= 0; i--) {
            const entry = leafDecayQueue[i];
            entry.timer -= delta;
            if (entry.timer > 0) continue;
            const key = `${entry.x},${entry.y},${entry.z}`;
            const current = voxelMap.get(key);
            if (!current || current.type !== 'leaves') {
                leafDecayQueue.splice(i, 1);
                leafDecayScheduled.delete(key);
                continue;
            }
            if (hasSupportingLog(entry.x, entry.y, entry.z)) {
                entry.timer = 0.45 + Math.random() * 0.3;
                continue;
            }
            leafDecayQueue.splice(i, 1);
            leafDecayScheduled.delete(key);
            removeVoxel(entry.x, entry.y, entry.z);
        }
    }

    function dropSelectedBlock() {
        const type = selectableTypes[selectedIndex];
        if (!type || !blockMaterials[type]) return;
        if (type === 'water' || type === 'lava' || type === 'bedrock' || type === 'leaves') return;
        if (!inventory[type] || inventory[type] <= 0) return;
        const removed = removeItemFromInventory(type, 1);
        if (removed <= 0) return;
        const forward = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
        const spawnPos = camera.position.clone().add(forward.clone().multiplyScalar(0.8));
        spawnPos.y -= 0.2;
        const velocity = forward.multiplyScalar(2);
        velocity.y += 1;
        spawnDroppedItem(type, Math.floor(spawnPos.x), Math.floor(spawnPos.y), Math.floor(spawnPos.z), {
            worldPosition: spawnPos,
            velocity,
            pickupDelay: 0.4
        });
    }

    // Place a voxel of the given type at the specified coordinates.  A
    // standalone Mesh is created for dynamic blocks.  The voxelMap and
    // voxelInstances are updated accordingly.
    function placeVoxel(x, y, z, type) {
        const key = `${x},${y},${z}`;
        if (type === 'water') {
            const chunkKey = worldToChunkKey(x, z);
            const chunk = chunkMap.get(chunkKey);
            voxelMap.set(key, { type: type, chunk: chunk ? chunkKey : 'mod' });
            if (chunk) {
                if (!chunk.waterCells) chunk.waterCells = new Set();
                chunk.waterCells.add(key);
                refreshWaterForChunkAndNeighbours(chunk);
                voxelInstances.delete(key);
            } else {
                const mesh = new THREE.Mesh(cubeGeometry, blockMaterials.water);
                mesh.castShadow = false;
                mesh.receiveShadow = true;
                mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
                scene.add(mesh);
                modifiedMeshes.push(mesh);
                voxelInstances.set(key, { mesh: mesh, index: 0, chunk: 'mod', type });
            }
            fluidQueue.push({ x: x, y: y, z: z });
            return;
        }
        const mat = blockMaterials[type];
        const mesh = new THREE.Mesh(cubeGeometry, mat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
        scene.add(mesh);
        modifiedMeshes.push(mesh);
        voxelMap.set(key, { type: type, chunk: 'mod' });
        voxelInstances.set(key, { mesh: mesh, index: 0, chunk: 'mod', type });
        if (type !== 'leaves' && type !== 'lava') {
            const colKey = `${x},${z}`;
            if (heightMap[colKey] === undefined || y > heightMap[colKey]) {
                heightMap[colKey] = y;
            }
        }
    }

    // Remove a voxel at the given coordinates from the scene.  This will hide
    // the instanced block (by scaling it to zero) or remove a dynamic mesh.
    function removeVoxel(x, y, z) {
        const key = `${x},${y},${z}`;
        const info = voxelInstances.get(key);
        const oldEntry = voxelMap.get(key);
        const entryType = oldEntry ? oldEntry.type : (info ? info.type : null);
        if (entryType === 'water') {
            if (info && info.chunk === 'mod') {
                scene.remove(info.mesh);
                const idxMod = modifiedMeshes.indexOf(info.mesh);
                if (idxMod >= 0) modifiedMeshes.splice(idxMod, 1);
                voxelInstances.delete(key);
            } else if (info) {
                voxelInstances.delete(key);
            }
            if (oldEntry) {
                if (oldEntry.chunk && oldEntry.chunk !== 'mod') {
                    const owningChunk = chunkMap.get(oldEntry.chunk);
                    if (owningChunk && owningChunk.waterCells) {
                        owningChunk.waterCells.delete(key);
                    }
                    voxelMap.delete(key);
                    if (owningChunk) refreshWaterForChunkAndNeighbours(owningChunk);
                } else {
                    voxelMap.delete(key);
                }
            }
            recomputeColumnHeight(x, z);
            return;
        }
        if (info) {
            if (info.chunk === 'mod') {
                scene.remove(info.mesh);
                const idx = modifiedMeshes.indexOf(info.mesh);
                if (idx >= 0) modifiedMeshes.splice(idx, 1);
            } else if (info.mesh && info.mesh.isInstancedMesh) {
                const inst = info.mesh;
                const idxInst = info.index;
                const m = new THREE.Matrix4();
                m.makeScale(0, 0, 0);
                inst.setMatrixAt(idxInst, m);
                inst.instanceMatrix.needsUpdate = true;
            }
            voxelInstances.delete(key);
        } else if (oldEntry) {
            if (oldEntry.chunk === 'mod') {
                for (let i = modifiedMeshes.length - 1; i >= 0; i--) {
                    const mesh = modifiedMeshes[i];
                    if (Math.abs(mesh.position.x - (x + 0.5)) < 0.01 &&
                        Math.abs(mesh.position.y - (y + 0.5)) < 0.01 &&
                        Math.abs(mesh.position.z - (z + 0.5)) < 0.01) {
                        scene.remove(mesh);
                        modifiedMeshes.splice(i, 1);
                        break;
                    }
                }
            } else {
                const chunk = chunkMap.get(oldEntry.chunk);
                if (chunk && chunk.instancedByType) {
                    const inst = chunk.instancedByType.get(oldEntry.type);
                    if (inst && inst.isInstancedMesh) {
                        const tmpMatrix = new THREE.Matrix4();
                        const tmpPos = new THREE.Vector3();
                        const zero = new THREE.Matrix4().makeScale(0, 0, 0);
                        const instanceCount = (typeof inst.count === 'number') ? inst.count : inst.instanceMatrix.count;
                        let found = false;
                        for (let i = 0; i < instanceCount; i++) {
                            inst.getMatrixAt(i, tmpMatrix);
                            tmpPos.setFromMatrixPosition(tmpMatrix);
                            if (Math.abs(tmpPos.x - (x + 0.5)) < 0.01 &&
                                Math.abs(tmpPos.y - (y + 0.5)) < 0.01 &&
                                Math.abs(tmpPos.z - (z + 0.5)) < 0.01) {
                                inst.setMatrixAt(i, zero);
                                inst.instanceMatrix.needsUpdate = true;
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            inst.instanceMatrix.needsUpdate = true;
                        }
                    }
                }
            }
        }
        if (!oldEntry) return;
        let dropType = oldEntry.type;
        // Remove the voxel from the map before spawning a drop so
        // that collision checks treat the space as empty.  Store
        // the type for later use.
        if (oldEntry.type === 'leaves') {
            const scheduled = leafDecayScheduled.get(key);
            if (scheduled) {
                const idx = leafDecayQueue.indexOf(scheduled);
                if (idx >= 0) leafDecayQueue.splice(idx, 1);
                leafDecayScheduled.delete(key);
            }
        }
        voxelMap.delete(key);
        if (oldEntry.type === 'wood') {
            scheduleLeavesAround(x, y, z);
        }
        recomputeColumnHeight(x, z);
        if (dropType) {
            // Spawn a dropped item corresponding to the removed block now that the
            // column height has been updated so the drop sits atop the new surface.
            const supportY = findSupportingBlockY(x, y - 1, z);
            spawnDroppedItem(dropType, x, y, z, { surfaceHint: supportY });
        }
    }

    // Spawn debris particles when a block is broken.  Each piece is a small
    // cube that will move upward and outward, then fall down under gravity.
    function spawnDebris(x, y, z, type) {
        const count = 6;
        for (let i = 0; i < count; i++) {
            const geom = new THREE.BoxBufferGeometry(0.2, 0.2, 0.2);
            const mat = blockMaterials[type];
            const dMesh = new THREE.Mesh(geom, mat);
            dMesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            const vel = new THREE.Vector3((Math.random() - 0.5) * 2, Math.random() * 2 + 1, (Math.random() - 0.5) * 2);
            debrisPieces.push({ mesh: dMesh, velocity: vel, life: 1.5 });
            scene.add(dMesh);
        }
    }

    // Play a random dig/break sound appropriate for the given block type.
    function playRandomDigSound(type) {
        let category;
        if (type === 'wood') category = 'wood';
        else if (type === 'stone' || type === 'bedrock' || type === 'sand' || type === 'glowstone' || type === 'ice') category = 'stone';
        else category = 'grass';
        const arr = digSounds[category];
        if (!arr || arr.length === 0) return;
        const idx = Math.floor(Math.random() * arr.length);
        const s = arr[idx];
        if (!s.buffer) return;
        if (s.isPlaying) s.stop();
        s.play();
    }

    function applyUnderwaterFilter(sound, active) {
        if (!sound || typeof sound.setFilter !== 'function') return;
        if (active) {
            let filter = underwaterSfxFilters.get(sound);
            if (!filter && audioListener && audioListener.context) {
                filter = audioListener.context.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1100, audioListener.context.currentTime);
                filter.Q.value = 0.7;
                underwaterSfxFilters.set(sound, filter);
            }
            if (filter) sound.setFilter(filter);
            if (typeof sound.setPlaybackRate === 'function') {
                sound.setPlaybackRate(UNDERWATER_SFX_PITCH);
            }
        } else {
            sound.setFilter(null);
            if (typeof sound.setPlaybackRate === 'function') {
                sound.setPlaybackRate(1);
            }
        }
    }

    function updateUnderwaterAudioState(active) {
        if (underwaterAudioActive === active) return;
        underwaterAudioActive = active;
        if (music) {
            if (active) {
                if (!musicUnderwaterFilter && audioListener && audioListener.context) {
                    const filter = audioListener.context.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(900, audioListener.context.currentTime);
                    filter.Q.value = 1.05;
                    musicUnderwaterFilter = filter;
                }
                if (musicUnderwaterFilter) music.setFilter(musicUnderwaterFilter);
                if (typeof music.setPlaybackRate === 'function') {
                    music.setPlaybackRate(UNDERWATER_MUSIC_PITCH);
                }
            } else {
                music.setFilter(null);
                if (typeof music.setPlaybackRate === 'function') {
                    music.setPlaybackRate(1);
                }
            }
        }
        if (Array.isArray(stepSounds)) {
            stepSounds.forEach((sound) => applyUnderwaterFilter(sound, active));
        }
        Object.keys(digSounds).forEach((cat) => {
            digSounds[cat].forEach((sound) => applyUnderwaterFilter(sound, active));
        });
        if (damageSounds.length) {
            damageSounds.forEach((clip) => {
                clip.playbackRate = active ? UNDERWATER_SFX_PITCH : 1;
            });
        }
        if (deathSound) {
            deathSound.playbackRate = active ? UNDERWATER_SFX_PITCH : 1;
        }
        if (typeof applyVolumeSettings === 'function') {
            applyVolumeSettings();
        }
    }

    // Spawn a dropped item at the given world coordinates.  The item
    // appears as a small cube with the same material as the block.  A
    // random initial velocity is assigned to give the item a slight
    // bounce.  The item will fall under gravity until it reaches the
    // ground and can then be collected by the player.
    function spawnDroppedItem(type, x, y, z, options = {}) {
        // Do not drop items for water, leaves or fluids; bedrock also drops nothing.
        if (type === 'water' || type === 'leaves' || type === 'lava' || type === 'bedrock') return;
        let mesh;
        let halfSize = DROP_HALF_SIZE;
        if (blockMaterials[type]) {
            const geom = new THREE.BoxBufferGeometry(0.4, 0.4, 0.4);
            mesh = new THREE.Mesh(geom, blockMaterials[type]);
        } else if (type === 'stick') {
            mesh = createStickMesh();
            mesh.scale.multiplyScalar(0.6);
            halfSize = 0.28;
        } else if (TOOL_TYPES.has(type)) {
            const [variant, kind] = type.split('_');
            const factory = TOOL_FACTORIES[kind];
            if (factory) {
                mesh = factory({ variant });
                mesh.scale.multiplyScalar(0.7);
                halfSize = 0.32;
            }
        }
        if (!mesh) {
            const geom = new THREE.BoxBufferGeometry(0.4, 0.4, 0.4);
            mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({ color: 0xffffff }));
        }
        if (mesh.isMesh) {
            mesh.castShadow = true;
            mesh.receiveShadow = true;
        } else if (mesh.traverse) {
            mesh.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        }
        if (options.worldPosition) {
            mesh.position.copy(options.worldPosition);
        } else {
            const ix = Math.floor(x);
            const iz = Math.floor(z);
            let surfaceY;
            if (options.surfaceHint !== undefined) {
                surfaceY = (options.surfaceHint !== -Infinity)
                    ? options.surfaceHint + 1 + DROP_HALF_SIZE
                    : undefined;
            }
            if (surfaceY === undefined) {
                const support = findSupportingBlockY(ix, typeof y === 'number' ? y - 1 : CHUNK_HEIGHT - 1, iz);
                if (support !== -Infinity) {
                    surfaceY = support + 1 + halfSize;
                } else {
                    const highest = getHighestBlockY(ix + 0.5, iz + 0.5);
                    surfaceY = (highest !== -Infinity) ? highest + 1 + halfSize : y + 0.6;
                }
            }
            mesh.position.set(ix + 0.5, surfaceY, iz + 0.5);
        }
        if (TOOL_TYPES.has(type) || type === 'stick') {
            mesh.rotation.set(-0.45, Math.random() * Math.PI * 2, 0.18);
        } else {
            mesh.rotation.y = Math.random() * Math.PI * 2;
        }
        const velocity = options.velocity ? options.velocity.clone() : new THREE.Vector3(
            (Math.random() - 0.5) * 0.3,
            0.3 + Math.random() * 0.3,
            (Math.random() - 0.5) * 0.3
        );
        const spinSpeed = options.spinSpeed || (2 + Math.random() * 2);
        const pickupDelay = (typeof options.pickupDelay === 'number') ? options.pickupDelay : 0.25;
        const floatPhase = Math.random() * Math.PI * 2;
        droppedItems.push({
            mesh: mesh,
            type: type,
            velocity: velocity,
            grounded: false,
            spinSpeed,
            floatPhase,
            hoverTime: 0,
            restingY: mesh.position.y,
            pickupCooldown: pickupDelay,
            halfSize
        });
        scene.add(mesh);
    }

    // Add an item to the player's inventory.  Creates a new entry if needed.
    function addItemToInventory(type, count = 1) {
        if (!type || count <= 0) return 0;
        const limit = getStackLimit(type);
        if (!inventory[type]) inventory[type] = 0;
        const current = inventory[type];
        const space = limit - current;
        if (space <= 0) return 0;
        const added = Math.min(space, count);
        inventory[type] = current + added;
        if (added > 0) {
            discoveredTypes.add(type);
            if (isHotbarAssignable(type)) {
                ensureHotbarHasType(type);
                refreshHotbarSlotForType(type);
            }
            if (selectableTypes[selectedIndex] === type) updateHandBlockMaterial();
        }
        if (inventoryOpen) updateInventoryUI();
        return added;
    }

    function removeItemFromInventory(type, count = 1) {
        if (!type || count <= 0) return 0;
        if (!inventory[type]) return 0;
        const removed = Math.min(count, inventory[type]);
        if (removed <= 0) return 0;
        inventory[type] -= removed;
        if (inventory[type] <= 0) {
            delete inventory[type];
            const idx = selectableTypes.indexOf(type);
            if (idx >= 0) assignHotbarSlot(idx, null);
        } else {
            refreshHotbarSlotForType(type);
            if (selectableTypes[selectedIndex] === type) updateHandBlockMaterial();
        }
        if (inventoryOpen) updateInventoryUI();
        return removed;
    }

    // Update dropped item positions and handle pickup.  Items fall under
    // gravity until they touch the ground.  When the player moves close
    // enough to an item, it is collected and added to the inventory.
    function updateDroppedItems(delta) {
        if (droppedItems.length === 0) return;
        const gravity = -9.8;
        const pickRadius = 1.0;
        const bobAmplitude = 0.07;
        const toRemove = [];
        let collectedCount = 0;
        for (let i = 0; i < droppedItems.length; i++) {
            const item = droppedItems[i];
            item.hoverTime = (item.hoverTime || 0) + delta;
            if (item.pickupCooldown && item.pickupCooldown > 0) {
                item.pickupCooldown = Math.max(0, item.pickupCooldown - delta);
            }
            const spin = item.spinSpeed || 0;
            if (spin !== 0) {
                item.mesh.rotation.y += spin * delta;
            }
            item.mesh.rotation.x = 0.4 + Math.sin(item.hoverTime * 2 + (item.floatPhase || 0)) * 0.1;
            item.mesh.rotation.z = Math.cos(item.hoverTime * 1.6 + (item.floatPhase || 0)) * 0.08;
            // Apply gravity each frame so items begin falling immediately if their support disappears.
            item.velocity.y += gravity * delta;
            item.mesh.position.addScaledVector(item.velocity, delta);

            const ix = Math.floor(item.mesh.position.x);
            const iz = Math.floor(item.mesh.position.z);
            const dropHalf = item.halfSize || DROP_HALF_SIZE;
            const bottomY = item.mesh.position.y - dropHalf - 0.001;
            const supportY = findSupportingBlockY(ix, Math.floor(bottomY), iz);
            if (supportY !== -Infinity) {
                const restingY = supportY + 1 + dropHalf;
                if (item.mesh.position.y <= restingY) {
                    item.mesh.position.y = restingY;
                    item.velocity.y = 0;
                    item.grounded = true;
                    item.restingY = restingY;
                } else {
                    item.grounded = false;
                }
            } else {
                item.grounded = false;
            }

            if (item.grounded) {
                // Apply simple horizontal damping so items settle instead of sliding endlessly.
                const damping = Math.max(0, 1 - delta * 6);
                item.velocity.x *= damping;
                item.velocity.z *= damping;
                if (Math.abs(item.velocity.x) < 0.01) item.velocity.x = 0;
                if (Math.abs(item.velocity.z) < 0.01) item.velocity.z = 0;
                const hoverOffset = Math.sin(item.hoverTime * 4 + (item.floatPhase || 0)) * bobAmplitude;
                item.mesh.position.y = (item.restingY !== undefined ? item.restingY : item.mesh.position.y) + hoverOffset;
            } else {
                item.restingY = item.mesh.position.y;
            }
            // Check for pickup
            const dx = item.mesh.position.x - camera.position.x;
            const dy = item.mesh.position.y - camera.position.y;
            const dz = item.mesh.position.z - camera.position.z;
            if (dx*dx + dy*dy + dz*dz < pickRadius * pickRadius && (!item.pickupCooldown || item.pickupCooldown <= 0)) {
                const added = addItemToInventory(item.type, 1);
                if (added > 0) {
                    toRemove.push(item);
                    collectedCount += added;
                } else {
                    item.pickupCooldown = 0.4;
                }
            }
        }
        // Play pickup sound if any collected
        if (collectedCount > 0) {
            let soundUrl;
            if (collectedCount > 1) {
                soundUrl = 'https://github.com/bellasaunders25/VoxelVerse-Assets/raw/refs/heads/main/pop_sound_effect-1758966766407.mp3';
            } else {
                soundUrl = 'https://github.com/bellasaunders25/VoxelVerse-Assets/raw/refs/heads/main/pop_sound_effect-%232-1758966708680.mp3';
            }
            const audio = new Audio(soundUrl);
            audio.playbackRate = 0.9 + Math.random() * 0.2;
            audio.volume = 0.6 * masterVolume * sfxVolume;
            audio.play();
        }
        // Remove collected items
        toRemove.forEach((item) => {
            const idx = droppedItems.indexOf(item);
            if (idx >= 0) droppedItems.splice(idx, 1);
            scene.remove(item.mesh);
        });
    }

    // Spread fluid (water) to neighbouring empty cells.  This simple
    // simulation processes a small number of queued water cells each
    // frame.  For each cell in the queue, we attempt to flow downwards
    // first; if the space below is empty and not bedrock, we add water
    // there.  Otherwise we try to spread horizontally.  Newly spawned
    // water cells are added back to the queue for further spreading.
    function updateFluidSimulation() {
        const maxPerFrame = 20;
        let processed = 0;
        while (fluidQueue.length > 0 && processed < maxPerFrame) {
            const cell = fluidQueue.shift();
            processed++;
            const { x, y, z } = cell;
            // If this water cell no longer exists (e.g. replaced by solid block) skip
            const key = `${x},${y},${z}`;
            const entry = voxelMap.get(key);
            if (!entry || entry.type !== 'water') continue;
            // Try to flow downwards first
            const downKey = `${x},${y-1},${z}`;
            if (y > 0 && !voxelMap.has(downKey)) {
                placeVoxel(x, y-1, z, 'water');
                fluidQueue.push({ x: x, y: y-1, z: z });
                continue;
            }
            // Spread horizontally to four directions
            const dirs = [ [1,0], [-1,0], [0,1], [0,-1] ];
            for (let i = 0; i < dirs.length; i++) {
                const nx = x + dirs[i][0];
                const nz = z + dirs[i][1];
                const nKey = `${nx},${y},${nz}`;
                // Only spread if the neighbour is empty and not above water level
                if (!voxelMap.has(nKey) && y >= 0) {
                    placeVoxel(nx, y, nz, 'water');
                    fluidQueue.push({ x: nx, y: y, z: nz });
                    // Spread to only one neighbour per frame to limit growth
                    break;
                }
            }
        }
    }

    // Generate a simple puffy cloud texture on a canvas.  The resulting
    // texture has a radial falloff from white in the centre to transparent
    // at the edges.  Using a small canvas keeps the texture lightweight
    // while still looking soft when scaled up.
    function createCloudTexture() {
        const size = 64;
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
        const grd = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
        grd.addColorStop(0, 'rgba(255,255,255,1)');
        grd.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, size, size);
        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.LinearFilter;
        tex.minFilter = THREE.LinearMipMapLinearFilter;
        tex.needsUpdate = true;
        return tex;
    }

    // Initialise the sky elements: clouds, sun, moon, stars and dynamic
    // lights.  This function should be called from init() after the
    // scene has been created.  It relies on the global variables defined
    // above and populates them accordingly.  The cloud sprites are
    // scattered in a square region around the origin; they are later
    // repositioned relative to the camera in updateClouds().
    function initSky() {
        // Create cloud texture if not already generated
        if (!cloudTexture) {
            cloudTexture = createCloudTexture();
        }
        // Cloud group.  Each cloud is a small cluster of white cubes
        // assembled into a group.  Clouds drift slowly across the sky and
        // wrap around when they leave the vicinity of the player.  This
        // yields the "blocky" look characteristic of Minecraft clouds.
        cloudGroup = new THREE.Group();
        // Increase the number of clouds and enlarge the region size so that
        // clouds fill more of the sky and wrap less frequently.
        const cloudCount = 80;
        const regionSize = 400; // width of the distribution area
        // Material for cloud cubes.  Using a semi‚Äëtransparent Lambert
        // material softens the clouds and lets the sky show through.  The
        // opacity controls the amount of transparency ‚Äì 0.7 gives a
        // translucent, blocky appearance.
        const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
        for (let i = 0; i < cloudCount; i++) {
            const g = new THREE.Group();
            // Random number of cubes for this cloud
            const cubeCount = 3 + Math.floor(Math.random() * 4);
            for (let j = 0; j < cubeCount; j++) {
                const cube = new THREE.Mesh(cubeGeometry, cloudMat);
                // Random offset relative to the cloud centre.  Keeping
                // positions integer makes the cloud look cubic.
                const ox = Math.floor(Math.random() * 3) - 1;
                const oy = Math.floor(Math.random() * 2);
                const oz = Math.floor(Math.random() * 3) - 1;
                cube.position.set(ox, oy, oz);
                g.add(cube);
            }
            // Random initial world position
            g.position.set(
                (Math.random() - 0.5) * regionSize,
                // Raise clouds much higher into the sky.  Clouds should
                // float far above the terrain similar to Minecraft.  A
                // base height of 120 with a small variation keeps them
                // consistently elevated.
                120 + Math.random() * 20,
                (Math.random() - 0.5) * regionSize
            );
            // Scale clouds to be roughly the size of normal blocks.
            // Using a scale around 4 yields blocky cloud clusters that
            // resemble Minecraft's clouds without appearing enormous.
            const s = 4 + Math.random() * 2;
            g.scale.set(s, s, s);
            // Assign a slow horizontal drift speed.  Positive values move
            // clouds eastward; negative values westward.  Store in userData
            // so updateClouds() can access it.
            g.userData.speed = 2 + Math.random() * 3;
            cloudGroup.add(g);
        }
        scene.add(cloudGroup);
        // Render clouds after the sun and moon so they appear in front when
        // depth testing is enabled.  A higher renderOrder causes an
        // object to be drawn later in the render pipeline.
        cloudGroup.renderOrder = 1;
        // Sun mesh: use a cube to match the blocky aesthetic.  A
        // Lambert material with an emissive component makes the sun
        // appear bright and glowing.  DepthWrite is disabled so the
        // sun does not occlude distant objects, while depthTest
        // remains enabled so that clouds can pass in front.  The sun
        // is scaled down slightly compared to earlier versions.
        {
            const sunGeo = new THREE.BoxGeometry(1, 1, 1);
            const sunMat = new THREE.MeshLambertMaterial({
                color: 0xffff80,
                emissive: 0xffffaa,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 1,
                depthWrite: false,
                depthTest: true,
                fog: false
            });
            sunMesh = new THREE.Mesh(sunGeo, sunMat);
            sunMesh.scale.set(35, 35, 35);
            // Give the sun a slight rotation so that its cube form is
            // visible from various angles.  Unlike a billboarded
            // circle, the cube's orientation remains fixed relative
            // to the world.
            sunMesh.rotation.set(Math.PI * 0.25, Math.PI * 0.15, 0);
            scene.add(sunMesh);
            // Add concentric glow rings around the sun for a radiant effect.
            const sunGlowRadii = [1.3, 1.8, 2.2];
            sunGlowRadii.forEach((r, idx) => {
                const ringGeo = new THREE.RingGeometry(r * 0.9, r, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xffff80,
                    transparent: true,
                    opacity: 0.25 / (idx + 1),
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    depthTest: true,
                    fog: false
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                // Scale ring to match sun size so radii remain proportional
                ring.scale.set(sunMesh.scale.x, sunMesh.scale.y, 1);
                // Position the ring slightly behind the sun so that the
                // glow appears around the cube rather than on top of it.  A
                // small negative Z offset ensures the ring stays behind
                // when the sun faces the camera.
                ring.position.z = -0.02;
                sunMesh.add(ring);
            });
        }
        // Moon mesh: use a cube geometry to approximate the blocky moon
        // from Minecraft.  Apply the existing stone texture from the
        // block materials as the moon's surface and slightly tint it
        // towards light grey.  Depth testing is enabled so clouds can
        // pass in front of the moon.  We scale the cube to make it
        // large and easily visible in the night sky.
        {
            const moonGeo = new THREE.BoxGeometry(1, 1, 1);
            let moonMap = null;
            if (blockMaterials && blockMaterials.stone && blockMaterials.stone.map) {
                moonMap = blockMaterials.stone.map;
            }
            const moonMat = new THREE.MeshLambertMaterial({ map: moonMap, color: 0xbfcfcf, transparent: true, opacity: 0.95, depthWrite: false, depthTest: true, fog: false });
            moonMesh = new THREE.Mesh(moonGeo, moonMat);
            // Reduce the moon size to be slightly smaller than before.
            moonMesh.scale.set(40, 40, 40);
            moonMesh.rotation.set(Math.PI * 0.15, Math.PI * 0.25, 0);
            scene.add(moonMesh);
            // Add glow rings around the moon with a subtle lunar halo effect.
            const moonGlowRadii = [1.2, 1.6, 2.0];
            moonGlowRadii.forEach((r, idx) => {
                const ringGeo = new THREE.RingGeometry(r * 0.9, r, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xbfcfcf,
                    transparent: true,
                    opacity: 0.2 / (idx + 1),
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    depthTest: true,
                    fog: false
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.scale.set(moonMesh.scale.x, moonMesh.scale.y, 1);
                // Offset lunar halo slightly behind the moon so it rings
                // around the cube instead of overlapping the front face.
                ring.position.z = -0.02;
                moonMesh.add(ring);
            });
        }
        // Star field: points on a sphere scaled up; attach to scene and
        // reposition relative to the camera each frame.  Setting depthWrite
        // to false ensures stars don't occlude other objects.
        {
            const positions = new Float32Array(STAR_COUNT * 3);
            for (let i = 0; i < STAR_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const x = Math.sin(phi) * Math.cos(theta);
                const y = Math.cos(phi);
                const z = Math.sin(phi) * Math.sin(theta);
                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;
            }
            const starGeom = new THREE.BufferGeometry();
            starGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, sizeAttenuation: true, transparent: true, opacity: 0.0, depthWrite: false });
            stars = new THREE.Points(starGeom, starMat);
            stars.scale.setScalar(1000);
            scene.add(stars);
        }
        // Ambient and directional lights for day/night transitions.  Remove
        // any previously created lights and store references so they can
        // be updated later.
        if (ambientLight) scene.remove(ambientLight);
        if (sunLight) scene.remove(sunLight);
        ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(0, 1, 0);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(2048, 2048);
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 600;
        sunLight.shadow.bias = -0.0005;
        scene.add(sunLight);
    }

    // Update the sky and lighting based on elapsed time.  This should
    // be called every frame from animate() with the delta time.  The
    // dayTime variable is incremented and wrapped to the range [0,1].  The
    // positions of the sun and moon, the sky/fog colours, the intensities
    // of lights, and the visibility/opacity of stars are all updated.
    function updateSky(delta) {
        if (!sunMesh || !moonMesh || !stars || !ambientLight || !sunLight) return;
        // advance dayTime; modulo to keep in [0,1]
        dayTime = (dayTime + delta / DAY_DURATION) % 1;
        // Compute an angle for the sun's orbit.  A value of 0
        // corresponds to sunrise; 0.25 is midday; 0.5 is sunset;
        // 0.75 is midnight; and 1 returns to sunrise.  The angle is
        // used to compute both the horizontal and vertical components of
        // the sun's position such that it follows a circular path in the
        // X‚ÄìY plane.  This matches Minecraft's sun and moon which rise in
        // the east, climb to the zenith, then set in the west.
        const angle = dayTime * Math.PI * 2;
        // Sun position: move along a circle around the origin in the
        // X‚ÄìY plane.  The X coordinate controls east/west position while
        // the Y coordinate controls height above the horizon.  A positive
        // Y value places the sun above the horizon; a negative value puts
        // it below and thus hidden.  Z remains zero so the sun always
        // stays directly ahead or behind in the Z axis.
        const sunX = Math.cos(angle) * SUN_DISTANCE;
        const sunY = Math.sin(angle) * SUN_DISTANCE;
        sunMesh.position.set(sunX, sunY, 0);
        // Always orient the sun so one face points toward the camera.  This
        // makes the cube appear like a flat disk with a ring behind it
        // similar to Minecraft's sun.  We adjust the sun's rotation
        // each frame so it faces the camera regardless of player
        // orientation.  Children (glow rings) follow this rotation.
        sunMesh.lookAt(camera.position);
        // Do not orient the sun toward the camera.  The sun is a
        // three‚Äëdimensional cube that retains its rotation relative to
        // the world.  Allowing it to rotate naturally gives a more
        // authentic, blocky appearance reminiscent of Minecraft.
        // Moon position: phase shifted by 180 degrees (œÄ radians) so
        // that it rises when the sun sets and vice versa.  Like the
        // sun, the moon follows the same circular path on the opposite
        // side of the sky.
        const moonAngle = angle + Math.PI;
        const moonX = Math.cos(moonAngle) * SUN_DISTANCE;
        const moonY = Math.sin(moonAngle) * SUN_DISTANCE;
        moonMesh.position.set(moonX, moonY, 0);
        // Do not constantly orient the moon toward the camera.  Unlike the
        // sun, the moon is a 3D cube in Minecraft and retains a fixed
        // orientation relative to the world.  Leaving its rotation
        // unchanged allows the player to see multiple faces of the cube.
        // Determine brightness factor based on the sun's height above the
        // horizon.  When the sun is above the horizon (sunY >= 0),
        // brightness increases from 0 at sunrise to 1 at midday.  When
        // the sun is below the horizon the brightness is zero.
        const brightness = Math.max(0, sunY / SUN_DISTANCE);
        // Interpolate sky and fog colours between night and day.  At
        // brightness 1 the sky is light blue; at 0 it is deep blue.
        const dayColor = new THREE.Color(0x87ceeb);
        const nightColor = new THREE.Color(0x020916);
        const skyColor = nightColor.clone().lerp(dayColor, brightness);
        if (currentBiomeInfo && currentBiomeInfo.skyTint) {
            const tint = new THREE.Color(currentBiomeInfo.skyTint);
            skyColor.lerp(tint, 0.35);
        }
        scene.background.copy(skyColor);
        scene.fog.color.copy(skyColor);
        const targetFogNear = currentBiomeInfo && currentBiomeInfo.fogNear ? currentBiomeInfo.fogNear : DEFAULT_FOG_RANGE.near;
        const targetFogFar = currentBiomeInfo && currentBiomeInfo.fogFar ? currentBiomeInfo.fogFar : DEFAULT_FOG_RANGE.far;
        scene.fog.near = THREE.MathUtils.lerp(scene.fog.near, targetFogNear, delta * 0.5);
        scene.fog.far = THREE.MathUtils.lerp(scene.fog.far, targetFogFar, delta * 0.5);
        // Adjust light intensities based on brightness and biome ambience.
        const ambientBoost = currentBiomeInfo ? (currentBiomeInfo.ambientBoost || 0) : 0;
        ambientLight.intensity = 0.15 + 0.45 * brightness + ambientBoost;
        sunLight.intensity = 0.05 + 0.75 * brightness + ambientBoost * 0.5;
        sunLight.position.set(sunX, sunY, 0);
        // Sun and moon visibility: show the sun only when it is above the
        // horizon; show the moon only when it is above the horizon.  This
        // yields proper rising and setting.
        sunMesh.visible = sunY >= 0;
        moonMesh.visible = moonY >= 0;
        // Optionally adjust opacities of the sun and moon slightly for
        // additional subtlety.  When the sun is low in the sky its
        // opacity decreases slightly.  Similarly for the moon.
        if (sunMesh.material && sunMesh.material.opacity !== undefined) {
            sunMesh.material.opacity = 0.5 + 0.5 * brightness;
        }
        if (moonMesh.material && moonMesh.material.opacity !== undefined) {
            const moonBrightness = Math.max(0, moonY / SUN_DISTANCE);
            moonMesh.material.opacity = 0.4 + 0.6 * moonBrightness;
        }
        // Stars fade in as brightness drops.  Use a squared relationship
        // for a smoother fade.  Only render stars when the sun is below
        // the horizon.
        const starOpacity = Math.pow(Math.max(0, 1 - brightness), 2);
        stars.material.opacity = starOpacity;
        stars.visible = starOpacity > 0.001;
        // Reposition stars to follow the camera
        stars.position.copy(camera.position);

        skyBrightness = brightness;

        // Show clouds only during the day.  When brightness drops below a
        // small threshold the clouds are hidden so that stars can shine
        // unobstructed.  cloudGroup may be undefined if sky elements have
        // not yet been initialised.
        if (typeof cloudGroup !== 'undefined' && cloudGroup) {
            cloudGroup.visible = brightness > 0.1;
        }
    }

    // Update cloud positions to maintain an infinite field.  Each cloud
    // sprite wraps around a square region centred on the camera.  They
    // always face the camera.
    function updateClouds(delta) {
        if (!cloudGroup) return;
        const camX = camera.position.x;
        const camZ = camera.position.z;
        // Define the wrapping region relative to the camera.  Clouds will
        // wrap around this square area when they travel too far.  A
        // larger region prevents frequent wraps.
        // Match the region size to initSky's distribution area.  A larger
        // region keeps clouds distributed across a wider area and reduces
        // noticeable wrapping.
        const region = 400;
        cloudGroup.children.forEach((cloud) => {
            // Move the cloud along the X axis by its speed.  A positive
            // speed drifts eastwards (increasing x).  Multiply by delta
            // for frame‚Äërate independence.
            if (cloud.userData && typeof cloud.userData.speed === 'number') {
                cloud.position.x += cloud.userData.speed * delta;
            }
            // Wrap the cloud around the region when it travels too far
            let dx = cloud.position.x - camX;
            if (dx > region) cloud.position.x -= region * 2;
            else if (dx < -region) cloud.position.x += region * 2;
            // Optionally wrap along z to keep distribution square
            let dz = cloud.position.z - camZ;
            if (dz > region) cloud.position.z -= region * 2;
            else if (dz < -region) cloud.position.z += region * 2;
        });
    }
    function spawnAmbientCreatures() {
        const fireflyCount = 24;
        const geometry = new THREE.SphereGeometry(0.12, 8, 8);
        for (let i = 0; i < fireflyCount; i++) {
            const hue = 0.32 + Math.random() * 0.08;
            const material = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 0.8, 0.6), transparent: true, opacity: 0.9 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set((Math.random() - 0.5) * 80, 6 + Math.random() * 8, (Math.random() - 0.5) * 80);
            scene.add(mesh);
            ambientCreatures.push({
                mesh,
                type: 'firefly',
                origin: mesh.position.clone(),
                radius: new THREE.Vector3(6 + Math.random() * 6, 2 + Math.random() * 2, 6 + Math.random() * 6),
                speed: 0.6 + Math.random() * 0.5,
                phase: Math.random() * Math.PI * 2,
                target: new THREE.Vector3()
            });
        }
    }
    function updateAmbientCreatures(delta) {
        if (ambientCreatures.length === 0) return;
        const allowedBiomes = ['crystal', 'skylands', 'rainforest', 'meadow'];
        const biomeKey = currentBiomeInfo ? currentBiomeInfo.key : 'meadow';
        const biomeAllows = allowedBiomes.includes(biomeKey);
        ambientCreatures.forEach((creature) => {
            const mesh = creature.mesh;
            if (!biomeAllows) {
                mesh.visible = false;
                return;
            }
            mesh.visible = true;
            creature.phase += delta * creature.speed;
            if (creature.type === 'firefly') {
                const ox = creature.origin.x;
                const oy = creature.origin.y;
                const oz = creature.origin.z;
                creature.target.set(
                    ox + Math.sin(creature.phase) * creature.radius.x,
                    oy + Math.sin(creature.phase * 1.7) * creature.radius.y,
                    oz + Math.cos(creature.phase * 0.8) * creature.radius.z
                );
                mesh.position.lerp(creature.target, delta * 2.0);
                const opacityTarget = (skyBrightness < 0.55) ? 0.9 : 0.15;
                mesh.material.opacity = THREE.MathUtils.lerp(mesh.material.opacity, opacityTarget, delta * 3);
                const hue = 0.32 + Math.sin(creature.phase) * 0.05;
                mesh.material.color.setHSL(hue, 0.8, 0.6);
            }
        });
    }
    // Delay world initialisation until the Play button is pressed.  Instead of
    // calling init() and animate() immediately, define a function that
    // performs this setup.  When the game starts, init() will build the
    // world and animate() will kick off the render loop.  A guard
    // prevents multiple initialisations.
    let gameStarted = false;
    function startGame() {
        if (gameStarted) return;
        gameStarted = true;
        init();
        animate();
    }
    // Expose helpers and the startGame function for the menu script.  The
    // regenerate() helper remains available for debug purposes via
    // window._voxelWorld.  startGame() will be called when the player
    // clicks the Play button in the main menu.
    window._voxelWorld = {
        regenerate: () => {
            seed = Math.floor(Math.random()*1e9);
            clearAllChunks();
            Object.keys(heightMap).forEach(k => delete heightMap[k]);
            perlinNoise = createPerlin(seed);
            heatNoise = createPerlin(seed ^ 0x51633);
            moistureNoise = createPerlin(seed ^ 0x9f4c3);
            mysticNoise = createPerlin(seed ^ 0x1f2a7);
            skyIslandNoise = createPerlin(seed ^ 0x7ab9d);
            biomeCache.clear();
            updateVisibleChunks(true);
        },
        getSeed: () => seed,
        startGame: startGame
    };
})();
</script>

<!-- Main menu behaviour and music.  This script runs after the page
     content is parsed.  It initialises menu music, sets up event
     listeners for user interaction and the Play button, and starts
     playing random menu tracks on loop until the game starts. -->
<script>
(() => {
    // Only one menu track ‚Äì Pixel Reflections ‚Äì is played on loop.  Additional
    // tracks can be added to this array if desired.
    const MENU_MUSIC_TRACKS = [
        'https://github.com/bellasaunders25/VoxelVerse-Assets/raw/refs/heads/main/Pixel%20Reflections.mp3'
    ];
    let menuMusicAudio = null;
    let menuMusicStarted = false;
    // Button hover/click sound effects
    const hoverSound = new Audio('https://github.com/bellasaunders25/VoxelVerse-Assets/raw/refs/heads/main/Button_Hover_sound_f-%231-1758959463352.mp3');
    const clickSound = new Audio('https://github.com/bellasaunders25/VoxelVerse-Assets/raw/refs/heads/main/Button_click_sound_f-%232-1758959535901.mp3');
    hoverSound.volume = 0.6;
    clickSound.volume = 0.7;
    // Play the menu music.  When it ends, restart it for continuous playback.
    function playRandomMenuTrack() {
        if (!menuMusicAudio) {
            menuMusicAudio = new Audio();
            menuMusicAudio.volume = 0.5;
            menuMusicAudio.addEventListener('ended', playRandomMenuTrack);
        }
        const url = MENU_MUSIC_TRACKS[Math.floor(Math.random() * MENU_MUSIC_TRACKS.length)];
        menuMusicAudio.src = url;
        menuMusicAudio.play().catch(() => {/* wait for user gesture */});
    }
    function startMenuMusic() {
        if (menuMusicStarted) return;
        menuMusicStarted = true;
        playRandomMenuTrack();
    }
    // Gradually fade out the provided audio over the given duration (ms).
    function fadeOutAudio(audio, duration) {
        const steps = 20;
        const stepTime = duration / steps;
        const initialVolume = audio.volume;
        let currentStep = 0;
        const iv = setInterval(() => {
            currentStep++;
            const newVol = initialVolume * (1 - currentStep / steps);
            audio.volume = Math.max(0, newVol);
            if (currentStep >= steps) {
                clearInterval(iv);
                audio.pause();
            }
        }, stepTime);
    }
    // Stop menu music immediately.
    function stopMenuMusic() {
        if (menuMusicAudio) {
            menuMusicAudio.pause();
            menuMusicAudio.currentTime = 0;
        }
    }
    // After first user interaction, begin playing menu music.
    function handleFirstInteraction() {
        document.removeEventListener('click', handleFirstInteraction);
        document.removeEventListener('keydown', handleFirstInteraction);
        startMenuMusic();
    }
    document.addEventListener('click', handleFirstInteraction);
    document.addEventListener('keydown', handleFirstInteraction);
    // Wire up hover and click sounds for menu buttons and icon buttons.
    function setupButtonSounds() {
        const buttons = document.querySelectorAll('.menu-btn:not(.disabled), .icon-btn');
        buttons.forEach(btn => {
            btn.addEventListener('mouseenter', () => {
                try {
                    hoverSound.currentTime = 0;
                    hoverSound.play();
                } catch (e) {}
            });
            btn.addEventListener('click', (e) => {
                const isDisabled = e.currentTarget.classList.contains('disabled');
                if (!isDisabled) {
                    try {
                        clickSound.currentTime = 0;
                        clickSound.play();
                    } catch (e2) {}
                }
            });
        });
    }
    // Handle Play button: fade out menu, fade music, show loading screen and start the game.
    function setupPlayButton() {
        const playBtn = document.getElementById('playButton');
        const mainMenu = document.getElementById('mainMenu');
        const loadingScreen = document.getElementById('loadingScreen');
        if (!playBtn) return;
        playBtn.addEventListener('click', () => {
            mainMenu.style.transition = 'opacity 0.6s ease-out';
            mainMenu.style.opacity = '0';
            mainMenu.style.pointerEvents = 'none';
            // Fade out menu music over 1.5 seconds
            if (menuMusicAudio) {
                fadeOutAudio(menuMusicAudio, 1500);
            }
            // Show loading screen
            if (loadingScreen) loadingScreen.classList.add('visible');
            // Start the game after a brief delay
            setTimeout(() => {
                if (window._voxelWorld && typeof window._voxelWorld.startGame === 'function') {
                    window._voxelWorld.startGame();
                }
                // Hide loading screen once the world has had a moment to generate
                setTimeout(() => {
                    if (loadingScreen) loadingScreen.classList.remove('visible');
                }, 2500);
            }, 1200);
        });
    }
    window.addEventListener('DOMContentLoaded', () => {
        setupButtonSounds();
        setupPlayButton();
        // Hook up the Options button on the main menu to show the
        // options overlay.  When clicked from the main menu the
        // options menu opens even though the game has not yet started.
        const mainOptsBtn = document.getElementById('mainOptionsButton');
        if (mainOptsBtn) {
            mainOptsBtn.addEventListener('click', (e) => {
                e.preventDefault();
                // Hide the main menu while options are displayed
                const mainMenuEl = document.getElementById('mainMenu');
                if (mainMenuEl) {
                    mainMenuEl.style.display = 'none';
                    mainMenuEl.style.opacity = '1';
                    mainMenuEl.style.pointerEvents = 'none';
                }
                // Sync slider values with current volume settings
                const masterSlider = document.getElementById('masterVolumeSlider');
                const musicSlider  = document.getElementById('musicVolumeSlider');
                const sfxSlider    = document.getElementById('sfxVolumeSlider');
                if (masterSlider) masterSlider.value = Math.round(((typeof window.masterVolume === 'number' ? window.masterVolume : 1.0) * 100));
                if (musicSlider)  musicSlider.value  = Math.round(((typeof window.musicVolume  === 'number' ? window.musicVolume  : 0.2) * 100));
                if (sfxSlider)    sfxSlider.value    = Math.round(((typeof window.sfxVolume    === 'number' ? window.sfxVolume    : 0.5) * 100));
                // Show the options menu
                const optionsMenuEl = document.getElementById('optionsMenu');
                if (optionsMenuEl) optionsMenuEl.style.display = 'flex';
            });
        }
    });
})();
</script>

<!-- Pause and options menu logic -->
<script>
(() => {
    window.addEventListener('DOMContentLoaded', () => {
        pauseMenuElement = document.getElementById('pauseMenu');
        optionsMenuElement = document.getElementById('optionsMenu');
        // Update global references to the pause and options menu elements
        window.pauseMenuElement = pauseMenuElement;
        window.optionsMenuElement = optionsMenuElement;
        const resumeBtn = document.getElementById('resumeButton');
        const pauseOptionsBtn = document.getElementById('pauseOptionsButton');
        const pauseQuitBtn = document.getElementById('pauseQuitButton');
        const optionsBackBtn = document.getElementById('optionsBackButton');
        const masterSlider = document.getElementById('masterVolumeSlider');
        const musicSlider  = document.getElementById('musicVolumeSlider');
        const sfxSlider    = document.getElementById('sfxVolumeSlider');
        // Initialise sliders using the global volume variables (if they exist)
        if (masterSlider) masterSlider.value = Math.round(((typeof window.masterVolume === 'number' ? window.masterVolume : 1.0) * 100));
        if (musicSlider)  musicSlider.value  = Math.round(((typeof window.musicVolume  === 'number' ? window.musicVolume  : 0.2) * 100));
        if (sfxSlider)    sfxSlider.value    = Math.round(((typeof window.sfxVolume    === 'number' ? window.sfxVolume    : 0.5) * 100));
        // Apply initial volume settings to all audio objects now that
        // menu sounds and loaders have been created.  Without this call
        // the menu music and UI sounds will not reflect saved volumes until
        // the game begins.
        if (typeof window.applyVolumeSettings === 'function') window.applyVolumeSettings();
        if (resumeBtn) {
            resumeBtn.addEventListener('click', () => {
                if (typeof hidePauseMenu === 'function') hidePauseMenu();
            });
        }
        if (pauseOptionsBtn) {
            pauseOptionsBtn.addEventListener('click', () => {
                if (typeof showOptionsMenu === 'function') showOptionsMenu();
            });
        }
        if (pauseQuitBtn) {
            pauseQuitBtn.addEventListener('click', () => {
                location.reload();
            });
        }
        if (optionsBackBtn) {
            optionsBackBtn.addEventListener('click', () => {
                if (typeof hideOptionsMenu === 'function') hideOptionsMenu();
            });
        }
        if (masterSlider) {
            masterSlider.addEventListener('input', () => {
                window.masterVolume = parseInt(masterSlider.value, 10) / 100;
                if (typeof window.applyVolumeSettings === 'function') window.applyVolumeSettings();
                if (typeof window.saveVolumeSettings === 'function') window.saveVolumeSettings();
            });
        }
        if (musicSlider) {
            musicSlider.addEventListener('input', () => {
                window.musicVolume = parseInt(musicSlider.value, 10) / 100;
                if (typeof window.applyVolumeSettings === 'function') window.applyVolumeSettings();
                if (typeof window.saveVolumeSettings === 'function') window.saveVolumeSettings();
            });
        }
        if (sfxSlider) {
            sfxSlider.addEventListener('input', () => {
                window.sfxVolume = parseInt(sfxSlider.value, 10) / 100;
                if (typeof window.applyVolumeSettings === 'function') window.applyVolumeSettings();
                if (typeof window.saveVolumeSettings === 'function') window.saveVolumeSettings();
            });
        }
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                // Determine current pointer lock and menu visibility states
                // Determine visibility of pause and options menus
                const pauseMenu = document.getElementById('pauseMenu');
                const optionsMenu = document.getElementById('optionsMenu');
                const pauseVisible = pauseMenu && pauseMenu.style.display === 'flex';
                const optionsVisible = optionsMenu && optionsMenu.style.display === 'flex';
                if (!pauseVisible) {
                    // When no pause menu is visible (the game is running), show it
                    if (typeof window.showPauseMenu === 'function') {
                        window.showPauseMenu();
                        e.preventDefault();
                    }
                } else if (pauseVisible && optionsVisible) {
                    // If both pause and options menus are visible, close options and return to pause
                    if (typeof window.hideOptionsMenu === 'function') {
                        window.hideOptionsMenu();
                        e.preventDefault();
                    }
                } else if (pauseVisible) {
                    // Otherwise toggle off the pause menu to resume
                    if (typeof window.hidePauseMenu === 'function') {
                        window.hidePauseMenu();
                        e.preventDefault();
                    }
                }
            }
        });

        // Hook up death screen buttons if present
        const respawnBtn = document.getElementById('respawnButton');
        const quitBtn    = document.getElementById('quitButton');
        if (respawnBtn) {
            respawnBtn.addEventListener('click', () => {
                // Respawn the player and hide the death screen
                if (typeof respawn === 'function') respawn();
            });
        }
        if (quitBtn) {
            quitBtn.addEventListener('click', () => {
                // Reload the page to return to the main menu
                location.reload();
            });
        }
    });
    window.showPauseMenu = function() {
        if (isPaused) return;
        if (!pauseMenuElement) return;
        // Mark the game as paused and expose this state on the global
        // window so that other scripts can detect it.
        isPaused = true;
        window.isPaused = true;
        if (document.pointerLockElement) {
            document.exitPointerLock();
        }
        pauseMenuElement.style.display = 'flex';
        // Update the exposed references whenever the menu is shown.
        window.pauseMenuElement = pauseMenuElement;
        window.optionsMenuElement = optionsMenuElement;
    };
    window.hidePauseMenu = function() {
        if (!isPaused) return;
        // Clear the paused state and update the global flags.
        isPaused = false;
        window.isPaused = false;
        if (pauseMenuElement) pauseMenuElement.style.display = 'none';
        if (optionsMenuElement) optionsMenuElement.style.display = 'none';
        // Update exposed references
        window.pauseMenuElement = pauseMenuElement;
        window.optionsMenuElement = optionsMenuElement;
        const canvas = document.querySelector('canvas');
        if (canvas && !document.pointerLockElement) {
            if (canvas.requestPointerLock) canvas.requestPointerLock();
        }
    };
    window.showOptionsMenu = function() {
        // Allow the options menu to be opened regardless of whether the game is paused.
        if (!optionsMenuElement) return;
        // Hide whichever overlay is currently visible.  If the game is paused
        // hide the pause menu; otherwise hide the main menu.
        if (window.isPaused) {
            if (pauseMenuElement) pauseMenuElement.style.display = 'none';
        } else {
            const mainMenuEl = document.getElementById('mainMenu');
            if (mainMenuEl) mainMenuEl.style.display = 'none';
        }
        optionsMenuElement.style.display = 'flex';
        // Sync the slider values with the current global volumes
        const masterSlider = document.getElementById('masterVolumeSlider');
        const musicSlider  = document.getElementById('musicVolumeSlider');
        const sfxSlider    = document.getElementById('sfxVolumeSlider');
        if (masterSlider) masterSlider.value = Math.round(((typeof window.masterVolume === 'number' ? window.masterVolume : 1.0) * 100));
        if (musicSlider)  musicSlider.value  = Math.round(((typeof window.musicVolume  === 'number' ? window.musicVolume  : 0.2) * 100));
        if (sfxSlider)    sfxSlider.value    = Math.round(((typeof window.sfxVolume    === 'number' ? window.sfxVolume    : 0.5) * 100));
    };
    window.hideOptionsMenu = function() {
        // Only proceed if the options menu exists
        if (!optionsMenuElement) return;
        optionsMenuElement.style.display = 'none';
        // If the game is paused, return to the pause menu; otherwise return to
        // the main menu.  This allows the same options overlay to be used
        // from both the main menu and the pause menu.
        if (window.isPaused) {
            // Show the pause menu if available
            if (pauseMenuElement) pauseMenuElement.style.display = 'flex';
        } else {
            // Reveal the main menu overlay again
            const mainMenuEl = document.getElementById('mainMenu');
            if (mainMenuEl) {
                mainMenuEl.style.display = 'flex';
                mainMenuEl.style.opacity = '1';
                mainMenuEl.style.pointerEvents = 'auto';
            }
        }
    };
})();
</script>
</body>
</html>
